#!/bin/bash
# usage: sbatch --nodes=1 --partition=sixhour "/panfs/pfs.local/home/j926w878/work/conda/snakecap/test12.sh" "A" 
module load R
module load anaconda
conda activate py36

### Description:
# Proccess the hit tables from test11.sh; generating edge matrices and group matrices for matches between group consensus sequences and genome samples
# This file contains line that are written in bash, and others that are written in R (below the line containing only "exit")

#MODE=$1    ### "A" (main job) or "B" (each subjob called from main job)

#if [ "$MODE"="A" ] ; then
MATCHESDIR=$1           # Path to the directory containing the input set of hit tables generated by blast
EDGEMATPATH=$2          # Where to save the edge matrix formed from concatenating rows from columns one and two of the hit tables in MATCHESDIR
CONGENGROUPMATPATH=$3   # Path where the group matrix should be saved. The group matrix indicated the group membership of each sequence in the edge matrix.
GROUPSUMMARYMATPATH=$4  # Path to the group summary matrix generated by test5.sh
ALLSEQSMATPATH=$5       # Path to "allseqs_key2.txt"
GROUPMATPATH=$6         # Path to the Groups Matrix

# Path to this bash script. 
SHij="/panfs/pfs.local/home/j926w878/work/conda/snakecap/test12.sh"

# MATCHESDIR="/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/matches_consensusSeqCapAndTargetRef_vs_genomes"
# EDGEMATPATH="/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/edgeMatrix_consensusSeqCapAndTargetRef_vs_genomes.txt"
# CONGENGROUPMATPATH="/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/groupMatrix_consensusSeqCapAndTargetRef_vs_genomes.txt"
# GROUPSUMMARYMAT="/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/groupseqs/N_UniqueSamples_Seqs_TargRefs_PerGroup_WithHeader_v2.txt"
# ALLSEQSMATPATH="/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/allseqs_key2.txt"
# GROUPMATPATH="/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/groupsMatrix_capVScap_capVStargets_v3.txt"

# Paths to al of the hit tables in MATCHESDIR
MATCHES_PATHS=$(find "$MATCHESDIR" -type f)
# All hit tables concatenated by rows
ALLMATCHES=$(cat $MATCHES_PATHS)
# First two columns of $ALLMATCHES
EDGES=$(echo "$ALLMATCHES" | awk '{print $1"\t"$2}' | sort -V)
# Write the edge matrix to $EDGEMATPATH
echo "$EDGES" > $EDGEMATPATH
# 
# Use igraph package to generate a group matrix...and to compare with the group SeqCap targetRef groups?
# Lines of this file defining R code
# 
EXITLINE=$(grep -Fnx 'exit' "$SHij" | cut -d: -f1)
RCODE=$(awk -v exl="$EXITLINE" 'NR>exl' "$SHij")
Rscript -e "$RCODE" "$EDGEMATPATH" "$CONGENGROUPMATPATH" "$GROUPSUMMARYMATPATH" "$ALLSEQSMATPATH" "$GROUPMATPATH"
#fi

exit

# lines below "exit" (which must be on a line by itself) are processed in R
.libPaths("/panfs/pfs.local/home/j926w878/work/R-packages")
library(data.table)
library(igraph)

args                <- commandArgs(trailingOnly=TRUE)
edgeMatPath         <- args[1]
SGMatPath           <- args[2]
groupSummaryMatPath <- args[3]
allseqsMat.path     <- args[4]
GMatPath            <- args[5]

edges.dt            <- data.table::fread(edgeMatPath,header=F,sep="\t")
#colnames(edges.dt)  <- c("qName", "sName")
edgeMat             <- as.matrix(edges.dt)
hits.clusters       <- igraph::components(igraph::graph_from_edgelist(edgeMat, directed=F))

### updates names used for supergroups, such that the trailing number used in the supergroup name = lowest number used for a group in the supergroup.
GroupsList         <- unname(igraph::groups(hits.clusters))
GroupsInGroupsList <- lapply(GroupsList,function(x){ gtools::mixedsort(x[grep("group",x)]) })
supergroupNames    <- gsub("group","supergroup",gsub("_consensus","",unlist(lapply(GroupsInGroupsList,function(x){x[1]}))))

### Constructing the dataframe "supergroupMembership.df"
GroupsList_lengths <- lengths(GroupsList)
Membership         <- unlist(lapply(1:length(GroupsList),function(x){rep(supergroupNames[x],GroupsList_lengths[x])}))
SequenceName       <- unlist(GroupsList)
supergroupMembership.df  <- data.frame(sequence=SequenceName, supergroup=Membership)

# At this point, the groups in supergroupMembership.df are not compatible with those used in for SeqCap or targetRef sequences.
# The groups that become linked by the genomes are those that would consensus sequences herein assigned to the same group.
## Need to calculate the number of SeqCap_Target group consensus seqs present in each Consensus_Genome group.
# Need to update 
ConsenusGroups_membership.df <- supergroupMembership.df[grep("consensus",supergroupMembership.df[,1]),]
#GroupsPerGroup               <- gtools::mixedsort(table(ConsenusGroups_membership.df[,2]))
GroupsPerGroup               <- lengths(lapply(GroupsList,grep,pattern="group"))

# 8226 Consensus_Genome groups with only one SeqCap_Target group
# 4751 Consensus_Genome groups with multiple one SeqCap_Target groups

# names(GroupsList) <- paste0("supergroup",1:length(GroupsList))
UnconnectedGroups_AllSeqsContained         <- GroupsList[which(GroupsPerGroup==1)]
UnconnectedGroups_ConsensusSeqsContained   <- lapply(GroupsList,function(x){x[grep("group",x)]})[GroupsPerGroup==1]
UnconnectedGroups_GenomeSeqsContained      <- lapply(GroupsList,function(x){x[-grep("group",x)]})[GroupsPerGroup==1]
ConnectedGroupsList_AllSeqsContained       <- GroupsList[which(GroupsPerGroup>1)]
ConnectedGroupsList_ConsensusSeqsContained <- lapply(GroupsList,function(x){x[grep("group",x)]})[GroupsPerGroup>1]
ConnectedGroupsList_GenomeSeqsContained    <- lapply(GroupsList,function(x){x[-grep("group",x)]})[GroupsPerGroup>1]

### Names of the query consensus group sequences that remain as a distinct group
GroupNames_OG_NoClash  <- unname(unlist(UnconnectedGroups_ConsensusSeqsContained))
### Names of the query consensus group sequences that are merged with another group
GroupNames_OG_Clash    <- unname(unlist(ConnectedGroupsList_ConsensusSeqsContained))
###

### Save some output files
write.table(supergroupMembership.df, file=SGMatPath, col.names=T,row.names=F,sep="\t",quote=F)
writeLines(GroupNames_OG_NoClash ,con=file.path(dirname(SGMatPath),"GroupNames_OG_NoClash.txt"))
writeLines(GroupNames_OG_Clash,con=file.path(dirname(SGMatPath),"GroupNames_OG_Clash.txt"))

Consensus_Genome_GroupsStrings               <- unlist(lapply(GroupsList,paste,collapse="|"))
Consensus_Genome_GroupsStrings_ConsensusSeqs <- unlist(lapply(GroupsList,function(x){paste(x[grep("group",x)],collapse="|")}))
Consensus_Genome_GroupsStrings_GenomeSeqs    <- unlist(lapply(GroupsList,function(x){paste(x[-grep("group",x)],collapse="|")}))

#### These are temporary definitions of SuperGroups!
#### The unalignable supergroups will be retroactively un-super if alignment (test14.sh) or cropping (test15_cropToSequence) leaves the supergroup empty.
# writeLines(Consensus_Genome_GroupsStrings, con=file.path(dirname(SGMatPath),"GroupsStrings_Consensus-vs-Genomes_AllSeqs.txt"))
writeLines(Consensus_Genome_GroupsStrings_ConsensusSeqs,con=file.path(dirname(SGMatPath),"GroupsStrings_Consensus-vs-Genomes_ConsensusSeqs.txt"))
# writeLines(Consensus_Genome_GroupsStrings_GenomeSeqs,con=file.path(dirname(SGMatPath),"GroupsStrings_Consensus-vs-Genomes_GenomeSeqs.txt"))

### Read in the group summary matrix generated in test5.sh; 
groupSummaryMat <- as.matrix(data.table::fread(groupSummaryMatPath,sep="\t",header=T))
groupMat
### Produce a matrix similar to the group summary matrix, but for supergroups.
# Supergroups = disconnected components of the union of the networks defined by edge matrices in: (1) "/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/edgeMats", and (2) "edgeMatrix_consensusSeqCapAndTargetRef_vs_genomes.txt"

supergroupName       <- unique(supergroupNames)
supergroupSummaryMat <- data.frame(supergroup=supergroupName, N_Groups=NA, groupNames=NA, N_Samples_SeqCap=NA, N_Seqs_SeqCap=NA, N_Samples_genomes=NA, N_Seqs_genomes=NA, N_targetRef=NA, SeqCap_seqNames=NA, SeqCap_OGNames=NA, genomes_seqNames=NA, genomes_OGNames=NA, targetRef_seqNames=NA, targetRef_OGNames=NA)
supergroupSummaryMat[,"N_Groups"]            <- GroupsPerGroup # unname(as.numeric(GroupsPerGroup))
supergroupSummaryMat[,"groupNames"]          <- gsub("_consensus","",Consensus_Genome_GroupsStrings_ConsensusSeqs)
supergroupSummaryMat[,"N_Samples_SeqCap"]    <- NA # TBD
supergroupSummaryMat[,"N_Seqs_SeqCap"]       <- NA # TBD
supergroupSummaryMat[,"N_Samples_genomes"]   <- lengths(lapply(GroupsList,function(x){unique(gsub("_.+","",x[-grep("group",x)]))}))
supergroupSummaryMat[,"N_Seqs_genomes"]      <- lengths(lapply(GroupsList,function(x){x[-grep("group",x)]}))
supergroupSummaryMat[,"N_targetRef"]         <- NA # TBD
supergroupSummaryMat[,"SeqCap_seqNames"]     <- NA # TBD
supergroupSummaryMat[,"SeqCap_OGNames"]      <- NA # TBD
supergroupSummaryMat[,"genomes_seqNames"]    <- Consensus_Genome_GroupsStrings_GenomeSeqs
supergroupSummaryMat[,"genomes_OGNames"]     <- NA # TBD
supergroupSummaryMat[,"targetRef_seqNames"]  <- NA # TBD
supergroupSummaryMat[,"targetRef_OGNames"]   <- NA # TBD
supergroupSummaryMat[,"NonGenome_seqNames"]  <- NA # TBD
supergroupSummaryMat[,"All_seqNames"]        <- NA # TBD

for i in 1:length(supergroupNames){
   groups.temp          <- unlist(strsplit(supergroupSummaryMat[i,"groupNames"],split="\\|"))
   NonGenome_seqNames_v <- paste(gtools::mixedsort(unlist(lapply(groups.temp,function(x){system(sprintf("awk -v i='%s' '{if($1 == i) {print $2}}' '%s'", x, GMatPath),intern=T)}))),collapse="|")
   NonGenome_seqNames_s <- paste(NonGenome_seqNames_v,collapse="|")
   supergroupSummaryMat[i,"NonGenome_seqNames"] <- NonGenome_seqNames_s
}

#  gmat.temp   <- groupSummaryMat[match(groups.temp,groupSummaryMat[,"group"]),,drop=FALSE]
#  supergroupSummaryMat[i,"targetRef_seqNames"] <- paste(gmat.temp[,"targetRef_seqNames"],collapse="|")
#  supergroupSummaryMat[i,"targetRef_OGNames"]  <- paste(gmat.temp[,"targetRef_Names"],collapse="|")

#test <- paste(gmat.temp[,"targetRef_seqNames"],collapse="|")
#targNames.temp    <- system(sprintf("awk -v x='%s' '{if($1 ~ x) {print $2}}' '%s'", targSeqNames[[i]], allseqsMat.path),intern=T)

# ~ returns partial matches, so "group10" as others are returned when searching "group1"
# I suspect that the problem is a sorting problem...
# NonGenome_seqNames <- system(sprintf("awk -v x='%s' '{if($1 == x) {print $2}}' '%s'", groups.temp, GMatPath),intern=T)
# NonGenome_seqNames <- system(sprintf("awk -v x='%s' '{if($1 == x) {print $2}}' '%s'", groups.temp, GMatPath),intern=T)

#groups.temp2 <- "group12273|group3|group3404|group3419"
# targNames.temp    <- system(sprintf("awk -v x='%s' '{if($1 ~ x) {print $2}}' '%s'", groups.temp, allseqsMat.path),intern=T)
#test = system(sprintf("awk '%s' '{print $1}' | grep 'group3\\|group3404'", GMatPath))

#"N_UniqueSamples"-
#  # next line probably would work with some fixing
#  targNames.temp    <- system(sprintf("awk -v x='%s' '{if($1 ~ x) {print $5}}' '%s'", groups.temp, groupSummaryMat),intern=T)
#}
#nSamples        <- list(); length(nSamples)     <- length(supergroupName)
#nSeqs           <- list(); length(nSeqs)        <- length(supergroupName)
#nTargs          <- list(); length(nTargs)       <- length(supergroupName)
#targSeqNames    <- list(); length(targSeqNames) <- length(supergroupName)
#targNames       <- list(); length(targNames)    <- length(supergroupName)

# allseqsMat.path <- "/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/allseqs_key2.txt"
# groupsMat       <- data.table::fread("/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/blast_database10/groupsMatrix_capVScap_capVStargets_v3.txt",sep="\t",header=F)

# allseqsMat.path <- args[4]
# Need to capture allseqsMat.path and supergroupMembership.df from the SH file!
# empty lists to fill

# for(i in 1:length(supergroupName)){
#   name.temp     <- supergroupName[i]
#   mat.temp      <- as.matrix(supergroupMembership.df[which(unname(unlist(supergroupMembership.df[,"supergroup"]))==name.temp),])
#   seqs.temp     <- mat.temp[,1]
#   nSeqs[[i]]    <- nrow(mat.temp)
#   samples.temp  <- unique(gsub("_.+","",seqs.temp))
#   nSamples[[i]] <- length(samples.temp)
#   if(any(samples.temp=="sample66")){
#     targSeqNames.temp <- seqs.temp[grep("sample66_",seqs.temp)]
#     targSeqNames[[i]] <- paste(targSeqNames.temp,collapse="|")
#     targNames.temp    <- system(sprintf("awk -v x='%s' '{if($1 ~ x) {print $2}}' '%s'", targSeqNames[[i]], allseqsMat.path),intern=T)
#     targNames[[i]]    <- paste(targNames.temp,collapse="|")
#     nTargs[[i]]       <- length(targSeqNames.temp)
#   } else {
#     targSeqNames[[i]] <- "NA"
#     targNames[[i]]    <- "NA"
#     nTargs[[i]]       <- 0
#   }
#   result       <- data.frame(group=groupName[i],N_UniqueSamples=nSamples[[i]],N_Seqs=nSeqs[[i]],N_targetRef=nTargs[[i]],targetRef_seqNames=targSeqNames[[i]],targetRef_Names=targNames[[i]])
#   if(i==1){
#     APPEND=F
#     HEADER=T
#   } else {
#     APPEND=T
#     HEADER=F
#   }
#   write.table(result,file=outpath,col.names=HEADER,row.names=F,sep="\t",quote=F,append=APPEND)
# }





