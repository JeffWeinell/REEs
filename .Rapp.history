additional.ID
additional.ID<-NULL
!is.null(additional.ID)
subject.id       <- refseq.names
subject.start    <- filtered.gff1B$start
subject.end      <- filtered.gff1B$end
new.names        <- paste0(refseq.names,":",subject.start,"-",subject.end)
new.names[1]
new.names[2]
Lacerta.agilis_exome <- Biostrings::readDNAStringSet(filepath="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Lacerta.agilis_exome_longer120bp.fas")
grep("NC_046312.1:84060818-84061670",names(Lacerta.agilis_exome))
grep("NC_046319.1:36771841-36772193",names(Lacerta.agilis_exome))
57111/length(Lacerta.agilis_exome)
6563/length(Lacerta.agilis_exome)
grep("NC_046312.1:81680187-81681417",names(Lacerta.agilis_exome))
6089/length(Lacerta.agilis_exome)
grep("NC_046313.1:104728512-104728660",names(Lacerta.agilis_exome))
18603/length(Lacerta.agilis_exome)
?data.table()
?fread()
library(REEs)
input.seqs = c("/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Crotalus.horridus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Ophiophagus.hannah.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Pantherophis.guttatus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Thamnophis.sirtalis.tblastx.best.hits_seqs.fas")#
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")#
reference.species = 4#
input.gff = NULL; output.path = NULL, alignments.out=NULL; subgroup=NULL; i.start=1; i.stop=NA; mafft.params="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6"
input.seqs = c("/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Crotalus.horridus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Ophiophagus.hannah.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Pantherophis.guttatus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Thamnophis.sirtalis.tblastx.best.hits_seqs.fas")#
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")#
reference.species = 4#
input.gff = NULL; output.path = NULL; alignments.out=NULL; subgroup=NULL; i.start=1; i.stop=NA; mafft.params="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6"
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ",".","-"),c("_","_","_"),species)
species
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","\.","-"),c("_","_","_"),species)
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","/.","-"),c("_","_","_"),species)
species
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)
species
species.names = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")
species  <- c(species.names[reference.species],species.names[-reference.species])
species
species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)
species
species  <- c(species.names[reference.species],species.names[-reference.species])#
	species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)#
	if(is.null(subgroup)){#
		subgroup <- species#
	}#
	if(is.null(output.path)){#
		output.path <- tempfile()#
		delete <- T#
	} else {#
		delete <- F#
	}
species
if(!is.null(alignments.out)){#
		dir.check.create(alignments.out)#
	}
is.subgroup     <- mgrep(query=subgroup,subject=species)
is.subgroup
is(input.seqs[[1]],"character")
input.seqs   <- c(input.seqs[reference.species],input.seqs[-reference.species])
input.seqs
species.seqs <- lapply(X=input.seqs,FUN=function(x){Biostrings::readDNAStringSet(x)})
if(is(input.seqs[[1]],"character")){#
		### Puts the input.seqs in the same order as species.#
		input.seqs   <- c(input.seqs[reference.species],input.seqs[-reference.species])#
		### Read in the sequences for each species as a DNAStringSet, and hold the set of DNAStringSets in a list#
		# Important not to name each DNAStringSet in the list#
		species.seqs <- lapply(X=input.seqs,FUN=function(x){Biostrings::readDNAStringSet(x)})#
	} else { #
		if(is(input.seqs[[1]],"DNAStringSet")){#
			##### Important not to name each DNAStringSet in the list#
			### Puts the input.seqs in the same order as species.#
			input.seqs        <- input.seqs[c(reference.species,c(1:length(input.seqs))[-reference.species])]#
			### Set species.seqs equal to input.seqs in this case.#
			species.seqs <- input.seqs#
		}#
		else {#
			stop("input.seqs must be a list of DNAStringSet objects or a vector of character strings with filepaths to sequences in fasta format")#
		}#
	}
length(species.seqs)
matches.list    <- lapply(X=species.seqs,FUN=function(x){ gsub("_Subject=.*","",names(x))})
length(matches.list)
all.loci        <- unique(unlist(matches.list))
matches.indices.all         <- lapply(X=matches.list,FUN=function(y){match(x=all.loci,table=y)})
species.seqs.all            <- mapply(FUN=function(X,Y){Z=Y[which(!is.na(Y))];X[Z]},X=species.seqs,Y=matches.indices.all,SIMPLIFY=F)
CDS.locus.identifier.all    <- mgsub(c(":","-"),c("_","_"),all.loci)
length(CDS.locus.identifier.all)
CDS.locus.identifier.all[1]
CDS.locus.identifier.all[2]
CDS.locus.identifier.all[3]
loci.ranges.all  <- mgsub(c(".*\\.1:","-"),c("","_"),all.loci)
loci.ranges.all[1]
length(all.loci)
all.loci[1]
mgsub(c(".*\\.1:","-"),c("","_"),all.loci[1])
mgsub(c(".+\\.1:","-"),c("","_"),all.loci[1])
mgsub(c("^.+\\.1:","-"),c("","_"),all.loci[1])
mgsub(c("^.+\\.1.","-"),c("","_"),all.loci[1])
loci.ranges.all  <- mgsub(c(".*\\.1.","-","_Gene=.+"),c("","_",""),all.loci)
loci.ranges.all[1]
loci.lengths.all <- (abs(as.numeric(gsub(".*_","",loci.ranges.all))-as.numeric(gsub("_.*","",loci.ranges.all)))+1)
loci.lengths.all[1]
1014392-1014266
is.null(input.gff)
length(all.loci)
gene.names.all <- rep(NA,length(all.loci))
if(is.na(i.start) | i.start > length(all.loci)){#
		### Default i.start, ie which exons to start the loop at#
		i.start <- 1#
	}#
	if(is.na(i.stop) | i.stop > length(all.loci)){#
		### Default i.stop, ie which exons to stop the loop at#
		i.stop  <- length(all.loci)#
	}
i.start
i.stop
index.matrix.all            <- do.call(rbind, matches.indices.all)
index.matrix.all
if(!is.null(names(species.seqs.all))){#
		names(species.seqs.all) <- NULL#
	}
temp.seqs.all               <- lapply(c(1:ncol(index.matrix.all)),function(input){do.call(c,mapply(FUN=function(A,B){C=B[which(!is.na(B))];A[C]},A=species.seqs.all,B=lapply(X=index.matrix.all[,input],FUN=function(x){x})))})
length(species.seqs.all)
species.seqs.all[[1]]
class(index.matrix.all)
mode(index.matrix.all)
length(index.matrix.all)
index.matrix.all[,1]
test = index.matrix.all[,1]
lapply(X=test, FUN=function(x){x})
as.list(test)
length(species.seqs.all)
which(!is.na(as.list(test)))
as.list(test)[which(!is.na(as.list(test)))]
species.seqs.all[as.list(index.matrix.all[,1])[which(!is.na(as.list(index.matrix.all[,1])))]]
organize.seqs.by.locus <- function(species.seqs,index.matrix){#
	num.loci <- 1:ncol(index.matrix)#
	lapply(X=1:num.loci,FUN=function(i){do.call(c,mapply(FUN=function(A,B){C=B[which(!is.na(B))]; A[C]}, A=species.seqs, B=as.list(index.matrix[,i])))})#
}
test <- organize.seqs.by.locus(species.seqs=species.seqs.all,index.matrix=index.matrix.all)
length(temp.seqs.all)
temp.seqs.all[1]
names.temp.seqs.all         <- apply(X=index.matrix.all,MARGIN=2,FUN=function(input){species[!is.na(input)]})
length(names.temp.seqs.all)
if(is(names.temp.seqs.all,"list")){#
		for(i in 1:length(temp.seqs.all)){#
			names(temp.seqs.all[[i]]) <- names.temp.seqs.all[[i]]#
		}#
	}#
	if(is(names.temp.seqs.all,"matrix")){#
		for(i in 1:length(temp.seqs.all)){#
			names(temp.seqs.all[[i]]) <- names.temp.seqs.all[,i]#
		}#
	}
tempMatrix.all           <- matrix(data=0, nrow=length(1:length(all.loci)), ncol=12+length(species))
tempMatrix.all
colnames(tempMatrix.all) <- c(paste0(species[1],".locus"), "num.Species","CountCover","absolutePIS","percentPIS","mean.pident", paste0("pident.",species), "gene.name",paste0("locus.length.",species[1]),"mean.variable.sites","min.pident.all","min.pident.subgroup","alignment.width")#
	tempMatrix.all[,1]             <- all.loci
nrow(tempMatrix.all)
length(gene.names.all)
gene.names.all[1]
colnames(tempMatrix.all) <- c(paste0(species[1],".locus"), "num.Species","CountCover","absolutePIS","percentPIS","mean.pident", paste0("pident.",species), "gene.name",paste0("locus.length.",species[1]),"mean.variable.sites","min.pident.all","min.pident.subgroup","alignment.width")#
	tempMatrix.all[,1]             <- all.loci#
	tempMatrix.all[,"gene.name"]   <- gsub("gene=","",gene.names.all)#
	tempMatrix.all[,"num.Species"] <- sapply(temp.seqs.all,length)
tempMatrix.all[1:10,]
# Find which column is the gene.name column#
	which.is.gene.name.column <- which(colnames(tempMatrix.all)=="gene.name")#
	# Columns that should be character mode#
	character.columns <- c(1,which.is.gene.name.column)#
	# Columns that should be numeric mode#
	numeric.columns   <- setdiff(1:ncol(tempMatrix.all),character.columns)#
	# Set the mode to numeric for those columns that should be numeric#
	tempMatrix.all[, numeric.columns] <- sapply(tempMatrix.all[, numeric.columns], as.numeric)
tempMatrix.all[1:10,]
class(tempMatrix.all)
tempMatrix.all[,1]             <- all.loci#
	tempMatrix.all[,"gene.name"]   <- gsub("gene=","",gene.names.all)#
	tempMatrix.all[,"num.Species"] <- sapply(temp.seqs.all,length)
tempMatrix   <- tempMatrix.all#
	temp.seqs    <- temp.seqs.all#
	loci.lengths <- loci.lengths.all
i=1
if (as.numeric(tempMatrix[i,"num.Species"])>1){#
			### aligns the ith locus of each species#
#			alignment.temp              <- REEs::mafft(temp.seqs[[i]],param="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6")#
			alignment.temp              <- REEs::mafft(temp.seqs[[i]],param=mafft.params)#
			### Number of sites in alignment#
			alignment.width             <- width(alignment.temp)[1]#
			### pairwise matrix of absolute genetic distance#
			distances                   <- 100*as.matrix(ape::dist.dna(ape::as.DNAbin(alignment.temp),model="raw",pairwise.deletion=T))#
			### Alternative method for calculating genetic distances. Doesnt seem any faster than the ape method.#
			# distances <- (100*(Biostrings::stringDist(alignment.temp)/alignment.width))#
			### pairwise matrix of percent genetic identity#
			pident                      <- round(100-distances,digits=2)#
			mean.pident                 <- round(mean(pident[1,-1]),digits=2)#
			### mean percent identity of the primary species to each of the other species.#
			tempMatrix[i,"mean.pident"] <- mean.pident#
			### percent identity of the primary species to each species in the alignment (including itself, with should be 100% idendical).#
			tempMatrix[i,(7:(length(species)+6))[species %in% names(alignment.temp)]] <- pident[1,]#
			if(any(!species %in% names(alignment.temp))){#
				tempMatrix[i,(7:(length(species)+6))[!species %in% names(alignment.temp)]] <- NA#
			}#
		}
library(REEs)
Aspidoscelis.marmoratus.hits <- "/Users/alyssaleinweber/Downloads/Aspidoscelis.marmoratus.tblastx.exons.hits_max5.hsps5.e15.txt"
input.table=Aspidoscelis.marmoratus.hits; output.table.path=NULL; remove.subseq.matches=T; min.bitscore=50; min.bitscore.difference=0
if(is(input.table,"data.table") | is(input.table,"matrix")){#
		all.matches <- as.data.frame(input.table)#
	}#
	## If input.table is a character string with the filepath, read the file in as a data.table and then coerce it to data frame.#
	if(is(input.table,"character")){#
		all.matches       <- as.data.frame(data.table::fread(input=input.table,sep="\t"))#
	}#
	# Set column names#
	colnames(all.matches) <- c("qseqid","sseqid","pident","length","mismatch","gapopen","qstart","qend","sstart","send","evalue","bitscore")#
	##### Set column modes#
	# Set which columns should be mode numeric#
	numeric.columns <- c(3:12)#
	# Set mode to numeric for those columns that should be numeric#
	all.matches[, numeric.columns] <- sapply(all.matches[, numeric.columns], as.numeric)#
	# Set which columns should be mode character#
	character.columns <- c(1:2)#
	# Set mode to "character" for the columns indexed in the character.columns vector#
	all.matches[, character.columns] <- sapply(all.matches[, character.columns], as.character)#
	### Filter matches with bitscore less than min.bitscore#
	if(any(all.matches$bitscore < min.bitscore)){#
		filtered.matches <- all.matches[-which(all.matches$bitscore < min.bitscore),]#
	} else {#
		filtered.matches <- all.matches#
	}
matches.ordered  <- filtered.matches[with(filtered.matches, order(filtered.matches[,"qseqid"], filtered.matches[,"bitscore"], decreasing=T)),]
remove.subseq.matches
query.subject.pairs <- distinct(matches.ordered[,c("qseqid","sseqid")])
query.subject.pairs <- dplyr::distinct(matches.ordered[,c("qseqid","sseqid")])
query.subject.pairs[1:10,]
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"]) && which which(matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"]) && which(matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"] && matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[2,"qseqid"] && matches.ordered[,"sseqid"] == query.subject.pairs[2,"sseqid"])
query.subject.pairs[2,"qseqid"]
query.subject.pairs[2,"sseqid"]
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"]) & which(matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"])
which(matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
matches.ordered[1:4,]
matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"]),]
matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[2,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[2,"sseqid"]),]
matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[3,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[3,"sseqid"]),]
lapply(X=1:10,FUN=function(i){ matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]})
matches.list        <- lapply(X=1:nrow(query.subject.pairs),FUN=function(i){ matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]})
length(matches.list)
nrow(query.subject.pairs)
matches.list <- list(); length(matches.list) <- nrow(query.subject.pairs)
i=1
matches.list[[i]] <- matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]
matches.list[1:10]
for(i in 1:100){#
			matches.list[[i]] <- matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]#
		}
matches.list[1:100]
for(i in 1:nrow(query.subject.pairs)){#
	#	for(i in 1:100){#
			matches.list[[i]] <- matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]#
		}
i
matches.list <- matches.list[1:4014]
min.list            <- lapply(matches.list,FUN=function(x){apply(X=x[,c("sstart","send")],MARGIN=1,FUN=min)})#
		max.list            <- lapply(matches.list,FUN=function(x){apply(X=x[,c("sstart","send")],MARGIN=1,FUN=max)})
matches.list[[1]]
apply(X=matches.list[[1]][,c("sstart","send")],MARGIN=1,FUN=min)
apply(X=matches.list[[1]][,c("sstart","send")],MARGIN=1,FUN=max)
matches.list <- matches.list[1:4013]
min.list            <- lapply(matches.list,FUN=function(x){apply(X=x[,c("sstart","send")],MARGIN=1,FUN=min)})
max.list            <- lapply(matches.list,FUN=function(x){apply(X=x[,c("sstart","send")],MARGIN=1,FUN=max)})
subject.ranges      <- IRanges::IRangesList(start=min.list,end=max.list)
drop.hits           <- IRanges::findOverlaps(subject.ranges,drop.self=T,type="within")
remove.rows.list    <- lapply(drop.hits,FUN=function(x){unique(as.matrix(x)[,1])})
dim(remove.rows.list)
length(remove.rows.list)
remove.rows.list[[1]]
remove.rows.list[[2]]
remove.rows.list[[4]]
function1           <- function(A,B){if(length(B)>0){A[-B,]} else{A}}
filtered.matches.ordered.temp  <- t(as.list(mapply(FUN=function1,A=matches.list,B=remove.rows.list)))
filtered.matches.ordered.temp2 <- list(); length(filtered.matches.ordered.temp2) <- ncol(filtered.matches.ordered.temp)
for(i in 1:ncol(filtered.matches.ordered.temp)){#
			filtered.matches.ordered.temp2[[i]] <- unlist(filtered.matches.ordered.temp[,i])#
		}
class(filtered.matches.ordered.temp2)
filtered.matches.ordered           <- as.data.frame(do.call(cbind,filtered.matches.ordered.temp2)
)
dim(filtered.matches.ordered)
filtered.matches.ordered[1:10,]
colnames(filtered.matches.ordered) <- colnames(matches.ordered)
##### Set column modes#
		# Set which columns should be mode numeric#
		numeric.columns <- c(3:12)#
		# Set mode to numeric for those columns that should be numeric#
		filtered.matches.ordered[, numeric.columns] <- sapply(filtered.matches.ordered[, numeric.columns], as.numeric)#
		# Set which columns should be mode character#
		character.columns <- c(1:2)#
		# Set mode to "character" for the columns indexed in the character.columns vector#
		filtered.matches.ordered[, character.columns] <- sapply(filtered.matches.ordered[, character.columns], as.character)
filtered.matches.ordered[1:10,]
best.matches          <- as.numeric(match(unique(filtered.matches.ordered$qseqid), filtered.matches.ordered$qseqid))
best.matches[1]
best.data             <- filtered.matches.ordered[best.matches,]
best.data[1:10,]
if(min.bitscore.difference!=0){#
		without.best.data     <- filtered.matches.ordered[-best.matches,]#
		second.best.matches   <- as.numeric(match(unique(filtered.matches.ordered$qseqid), without.best.data$qseqid))#
		second.best.data      <- without.best.data[second.best.matches]#
		#### If a query does not have a second best match, then a bitscore of zero is used for an dummy second match. There is no consequence for having a single strong match.#
		if(any(is.na(second.best.matches))){#
			second.best.data$bitscore[which(is.na(second.best.matches))] <- 0#
		}#
		bitscore.difference             <- as.numeric(best.data$bitscore)-as.numeric(second.best.data$bitscore)#
		if(any(bitscore.difference < min.bitscore.difference)){#
			best.data <- best.data[-which(bitscore.difference < min.bitscore.difference)]#
		}#
	}
best.data[1:10,]
result <- data.table::as.data.table(best.data)
result
library(REEs)
Lacerta.agilis_exome <- Biostrings::readDNAStringSet(filepath="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Lacerta.agilis_exome_longer120bp.fas")
grep("NC_046313.1:104728512-104728660",names(Lacerta.agilis_exome))
length(Lacerta.agilis_exome)
Lacerta.agilis.hits <- fread("/Users/alyssaleinweber/Downloads/Lacerta.agilis.tblastx.exons.hits_max10.hsps10.E10.txt")
Lacerta.agilis.hits
length(unique(Lacerta.agilis.hits$V1))
Lacerta.agilis_exome[1:100]
writeXStringSet(x=Lacerta.agilis_exome[1:100],filepath="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Lacerta.agilis_exome_longer120bp_First100Loci.fas")
as.character(Lacerta.agilis_exome[1])
gb.data <- "/Users/alyssaleinweber/Documents/publications/data/Weinell-et-al_2018_Cyclocorinae_DNA-sequences.gb"
gb.path <- gb.data
gb.data <- biofiles::gbRecord(gb.path)
gb.data
AA.temp           <- biofiles::translation(gb.data)
cdsFeatures.temp <- gb.data[[i]]["CDS"]
cdsFeatures.temp <- gb.data[[1]]["CDS"]
cdsFeatures.temp
Lacerta.agilis.genome_url          <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/009/819/535/GCF_009819535.1_rLacAgi1.pri/GCF_009819535.1_rLacAgi1.pri_genomic.fna.gz"
Lacerta.agilis_GFF    <- load.gff(input=Lacerta.agilis_GFF.url,local=F)
Lacerta.agilis_GFF    <- load.gff(Lacerta.agilis_GFF.url)
Lacerta.agilis_GFF.url   <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/009/819/535/GCF_009819535.1_rLacAgi1.pri/GCF_009819535.1_rLacAgi1.pri_genomic.gff.gz"
Lacerta.agilis_GFF    <- load.gff(Lacerta.agilis_GFF.url)
Lacerta.agilis_GFF[1:10,]
which(Lacerta.agilis_GFF$seqid=="NC_046312.1" & Lacerta.agilis_GFF$start=="5644" & Lacerta.agilis_GFF$end=="5770" & Lacerta.agilis_GFF$type=="CDS")
Lacerta.agilis_GFF[which(Lacerta.agilis_GFF$seqid=="NC_046312.1" & Lacerta.agilis_GFF$start=="5644" & Lacerta.agilis_GFF$end=="5770" & Lacerta.agilis_GFF$type=="CDS"),]
Biostrings::translate(x=Lacerta.agilis_exome[1])
?Biostrings
?Biostrings::translate
Biostrings::translate(x=Lacerta.agilis_exome[1],no.init.codon=T,if.fuzzy.codon="solve")
library(devtools)
getwd()
setwd("Documents/REEs")
devtools::document()
grep("NC_046313.1:103112986-103113903",names(Lacerta.agilis_exome))
grep("NC_046313.1:108730160-108730390",names(Lacerta.agilis_exome))
grep("NC_021766.1:14101-15243",names(Lacerta.agilis_exome))
Lacerta.agilis.hits <- data.table::fread("/Users/alyssaleinweber/Downloads/Lacerta.agilis.tblastx.hits_max5.hsps5.e05_Rv3.txt")
Lacerta.agilis.hits
length(unique(Lacerta.agilis.hits $qseqid))
length(unique(Lacerta.agilis.hits$qseqid))
unique(Lacerta.agilis.hits$qseqid)[1]
unique(Lacerta.agilis.hits$qseqid)[2]
length(unique(names(Lacerta.agilis_exome)))
nomatch.queries <- setdiff(names(Lacerta.agilis_exome),unique(Lacerta.agilis.hits$qseqid))
length(nomatch.queries)
nomatch.queries[1]
109589/9
(109589/9)*2
getwd()
devtools::document()
groups         <- sort(sample(1:8, size=10,replace=T))
groups
all(1:parallel.groups %in% groups)
parallel.groups=8
all(1:parallel.groups %in% groups)
all(c(1:parallel.groups) %in% groups)
c(1:parallel.groups) %in% groups
query=1:10
while(!all(1:parallel.groups %in% groups)){#
				groups         <- sort(sample(1:parallel.groups, size=length(query),replace=T))#
			}
groups
devtools::document()
.libPaths("/panfs/pfs.local/scratch/bi/j926w878/scratch_v1/Rv3.6")
