install_REEs <- function(packages.directory=.libPaths(),load.after.installation=F,token=NULL){#
	packages.dir   <- packages.directory#
	if(missing(packages.directory)| is.null(packages.directory)){#
		packages.dir <- .libPaths()#
	} else {#
		packages.dir <- packages.directory#
	}#
	# Not sure if its a good idea to set .libPaths within a function.#
#	.libPaths(packages.dir)#
	setwd(packages.dir)#
	### Load packages that that automatically included with R (R-core packages) and that are also needed for REEs#
	load.Rcore.dependencies   <- sapply(X=intersect(REEs.dependencies,Rcore.packages),FUN=library,character.only=T)#
	### It may or may not be a good idea to attach all of the packages currently in your namespace that intersect with REEs.dependencies to working environment.#
#	load.dependencies.in.Namespace <- sapply(X=intersect(REEs.dependencies,loadedNamespaces()),FUN=library,character.only=T)#
	### Get vector of REEs dependencies not in R-core packages.#
	REEs.dependencies.temp    <- setdiff(REEs.dependencies,Rcore.packages)#
	### Names of REEs dependencies that have not already been installed.#
	packages.to.install.temp  <- REEs.dependencies.temp[which(!(basename(REEs.dependencies.temp) %in% rownames(installed.packages(lib.loc=packages.dir))))]#
	### Install REEs dependencies that havent been installed. The order of installation defined in packages.to.install.temp decreases the chance of install failures.#
	if(length(packages.to.install.temp)!=0){#
		### Packages that depend on the BH package (Boost libraries). These will be installed last if they arent already installed.#
		wait.to.install       <- c("RSQLite","BiocParallel","Rsamtools","DECIPHER")#
		### The packages to load/install first. Internal order of entries also important.#
		packages.to.install   <-  setdiff(packages.to.install.temp,c("BH",wait.to.install))#
		### If there are any packages in packages.to.install, install them to packages.dir.#
		if(length(packages.to.install)!=0){#
			sapply(X=packages.to.install,FUN=REEs.Installer::package.check, pkgs.lib=packages.dir,deps=FALSE)#
		}#
		### Check that all packages in packages.to.install were successfully installed.#
		#which.failed <- packages.to.install[which(!(sapply(packages.to.install,basename) %in% c(rownames(installed.packages(lib.loc=packages.dir)),loadedNamespaces())))]#
		which.failed <- packages.to.install[which(!(basename(packages.to.install) %in% rownames(installed.packages(lib.loc=packages.dir))))]#
		if(length(which.failed)!=0){#
			### If any packages in packages.to.install were not installed, generate an error message indicating which package installs failed and then stop the install_REEs function.#
			stop("installation failed for packages",paste(which.failed))#
		} else {#
			### Load packages if they are not already in the loaded namespace.#
			packages.to.load <- setdiff(basename(packages.to.install),loadedNamespaces())#
			if(length(packages.to.load)>0){#
				### Returns the names of packages that were loaded.#
				colnames(sapply(X=packages.to.load,FUN=library,lib.loc=packages.dir,character.only=T))#
			}#
		}#
		### If the BH package is not installed to packages.dir and is not in the loaded namespace, then install "BH" to a temporary directory (not packages.dir).#
		### This package takes up a lot of space but it is only needed during installation for a few packages that need C++ compilation.#
		if(!("BH" %in% rownames(installed.packages(lib.loc=packages.dir))) & (!("BH" %in% loadedNamespaces()))){#
		#if(suppressWarnings(!require("BH", character.only = TRUE,lib.loc=packages.dir))){#
			### Define temporary directory where BH package should be installed#
			BH_tempdir <- tempdir()#
			### Install BH to BH_tempdir#
			BiocManager::install("BH",lib=BH_tempdir,dependencies=c("Depends", "Imports", "LinkingTo"))#
			### Check BH installation was successful#
			BH.check <- ("BH" %in% rownames(installed.packages(lib.loc=BH_tempdir)))#
			### If BH installation failed, generate a warning message and stop the install_REEs function, otherwise load and attach BH package.#
			if(!BH.check){#
				stop("installation failed for package BH")#
			} else {#
				library(BH,lib.loc=BH_tempdir)#
			}#
		} else {#
			### Load BH if it is installed in packages.dir but not yet loaded in any namespace, whereas dont install BH if it is in the loaded namespace even, if it isnt installed to packages.dir#
			if(("BH" %in% rownames(installed.packages(lib.loc=packages.dir))) & (!("BH" %in% loadedNamespaces()))){#
				library(BH,lib.loc=packages.dir)#
			}#
		}#
		### Install packages that need BH during installation if they are not already installed.#
		if(length(wait.to.install)!=0){#
			sapply(X=wait.to.install,FUN=REEs.Installer::package.check, pkgs.lib=packages.dir,deps=FALSE)#
		}#
		### Check if any of the BH-dependent packages failed to install.#
		which.failed2 <- wait.to.install[which(!(basename(wait.to.install) %in% rownames(installed.packages(lib.loc=packages.dir))))]#
		### If any of the BH-dependent packages failed to install, generate a warning message and stop the install_REEs function.#
		if(length(which.failed2)!=0){#
			stop("installation failed for packages",paste(which.failed2))#
		} else {#
			### Load BH-dependent packages if they are not already in the loaded namespace.#
			packages.to.load2 <- setdiff(basename(which.failed2),loadedNamespaces())#
			if(length(packages.to.load2)>0){#
				### Returns the names of BH-dependent packages that were just loaded.#
				colnames(sapply(X=packages.to.load2,FUN=library,lib.loc=packages.dir,character.only=T))#
			}#
		}#
	}#
	#### At this point, all of the REEs dependencies should be installed and loaded into the namespace. Time to install REEs packages.#
	# REEs.current is the data object that holds the url to the pre-build (.zip) REEs package#
	# REEs.url is the data object that holds the url to the post-build (tar.gz) REEs package#
	#####
	# Define temporary directory where REEs tar.gz file should be download; this is not where the package will be installed.#
	REEs_tempdir  <- tempdir()#
	### Download the tar.gz to REEs_tempdir#
	download.file(url=REEs.url,destfile=paste0(REEs_tempdir,"/REEs.tar.gz"))#
	### Install REEs to packages.dir#
	install.command <- paste("R CMD INSTALL -l",packages.dir,paste0("'",paste0(REEs_tempdir,"/REEs.tar.gz"),"'"))#
	system(install.command)#
	### Confirm that REEs was successfully installed. If not, generate a warning message and stop install_REEs function.#
	if(!("REEs" %in% rownames(installed.packages(lib.loc=packages.dir)))){#
		stop("REEs dependencies successfully installed and loaded, but REEs installation failed.")#
	} else {#
		### Load and attach REEs if load.after.installation=T, otherwise  #
		if(load.after.installation){#
			library("REEs",lib.loc=packages.dir,character.only = TRUE)#
			return("DONE")#
		} else {#
			return("DONE")#
		}#
	}#
}
library(REEs)
REEs::datasets(1)
Podarcis.muralis.genome_url        <- REEs::datasets(1)[which(datasets(1)[,1]=="Podarcis muralis"),2]
Podarcis.muralis.genome_url
Aspidoscelis.marmoratus.genome_url <- REEs::datasets(1)[which(datasets(1)[,1]=="Aspidoscelis marmoratus"),2]#
Lacerta.viridis.genome_url         <- REEs::datasets(1)[which(datasets(1)[,1]=="Lacerta viridis"),2]#
Lacerta.bilineata.genome_url       <- REEs::datasets(1)[which(datasets(1)[,1]=="Lacerta bilineata"),2]#
Lacerta.agilis.genome_url          <- REEs::datasets(1)[which(datasets(1)[,1]=="Lacerta agilis"),2]#
Zootoca.vivipara.genome_url        <- REEs::datasets(1)[which(datasets(1)[,1]=="Zootoca vivipara"),2]
Podarcis.muralis.genome_url       #
Aspidoscelis.marmoratus.genome_url#
Lacerta.viridis.genome_url        #
Lacerta.bilineata.genome_url      #
Lacerta.agilis.genome_url         #
Zootoca.vivipara.genome_url
REEs::datasets(1)[which(datasets(1)[,1]=="Podarcis muralis"),3]
REEs::datasets(1)[which(datasets(1)[,1]=="Aspidoscelis marmoratus"),3]
REEs::datasets(1)[which(datasets(1)[,1]=="Lacerta viridis"),3]
REEs::datasets(1)[which(datasets(1)[,1]=="Lacerta bilineata"),3]
REEs::datasets(1)[which(datasets(1)[,1]=="Lacerta agilis"),3]
REEs::datasets(1)[which(datasets(1)[,1]=="Zootoca vivipara"),3]
REEs::datasets(1)[which(datasets(1)[,1]=="Salvator merianae"),3]
Podarcis.muralis_GFF.url <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/004/329/235/GCF_004329235.1_PodMur_1.0/GCF_004329235.1_PodMur_1.0_genomic.gff.gz"#
Lacerta.agilis_GFF.url   <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/009/819/535/GCF_009819535.1_rLacAgi1.pri/GCF_009819535.1_rLacAgi1.pri_genomic.gff.gz"#
Zootoca.vivipara_GFF.url <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/011/800/845/GCF_011800845.1_UG_Zviv_1/GCF_011800845.1_UG_Zviv_1_genomic.gff.gz"
Podarcis.muralis_GFF  <- load.gff(input=Podarcis.muralis_GFF.url,local=F)
Lacerta.agilis_GFF    <- load.gff(input=Lacerta.agilis_GFF.url,local=F)
Podarcis.muralis_GFF[1:10,]
Zootoca.vivipara_GFF  <- load.gff(input=Zootoca.vivipara_GFF.url,local=F)
class(Zootoca.vivipara_GFF)
Zootoca.vivipara_GFF
length(unique(Zootoca.vivipara_GFF$seqid))
length(unique(Podarcis.muralis_GFF$seqid))
length(unique(Lacerta.agilis_GFF$seqid))
length(grep("CDS",Lacerta.agilis_GFF$type))
length(grep("gene",Podarcis.muralis_GFF$type))
length(grep("gene",Lacerta.agilis_GFF$type))
length(grep("gene",Zootoca.vivipara_GFF$type))
length(grep("CDS",Podarcis.muralis_GFF$type))
length(grep("CDS",Zootoca.vivipara_GFF$type))
Lacerta.agilis_GFF_CDS_longer120bp <- filter.gff(input.gff=Lacerta.agilis_GFF,feature.type="CDS",min.length=120)
nrow(Lacerta.agilis_GFF_CDS_longer120bp)
nrow(Lacerta.agilis_GFF)
write.table(x=Lacerta.agilis_GFF_CDS_longer120bp,file="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Lacerta.agilis_GFF_CDS_longer120bp.txt",quote=F,sep="\t",row.names=F,col.names=T)
Lacerta.agilis_exome   <- get.seqs.from.gff(input.seqs=Lacerta.agilis_genome.path,input.gff=Lacerta.agilis_GFF_CDS_longer120bp)
Lacerta.agilis_exome   <- get.seqs.from.gff(input.seqs=Lacerta.agilis.genome_url,input.gff=Lacerta.agilis_GFF_CDS_longer120bp)
Lacerta.agilis_GFF_CDS_longer120bp[1:10,]
download.file(url=Lacerta.agilis.genome_url, destfile="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/GCF_009819535.1_rLacAgi1.pri_genomic.fna.gz")
input.seqs="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/GCF_009819535.1_rLacAgi1.pri_genomic.fna.gz";input.gff=Lacerta.agilis_GFF_CDS_longer120bp
output.path = NULL;additional.ID=NULL
if("character" %in% class(input.gff)){#
		filtered.gff1B   <- data.table::fread(input.gff)#
	}#
	if("data.frame" %in% class(input.gff)){#
		filtered.gff1B   <- input.gff#
	}
refseq.names     <- unlist(filtered.gff1B[,1])#
	if(!is.null(additional.ID)){#
		### This is needed because the names in the gff file are not exactly the same as the ones in the genome file; they both link to a common Genbank Accession # though#
		ScaffoldKey      <- data.table::fread(additional.ID)#
		### Links the names in the gff file to the names of the CDS matches#
		alt.scaff.names  <- ScaffoldKey$ScaffoldName[match(refseq.names,ScaffoldKey$RefSeq.ScaffoldAccession)]#
		subject.id       <- alt.scaff.names#
		subject.start    <- as.numeric(filtered.gff1B$start)#
		subject.end      <- as.numeric(filtered.gff1B$end)#
		new.names        <- paste0(subject.id,"_",refseq.names,":",subject.start,"-",subject.end)	#
	} else {#
		subject.id       <- refseq.names#
		subject.start    <- as.numeric(filtered.gff1B$start)#
		subject.end      <- as.numeric(filtered.gff1B$end)#
		new.names        <- paste0(refseq.names,":",subject.start,"-",subject.end)	#
	}
length(refseq.names)
refseq.names[1]
"DNAStringSet" %in% class(input.seqs)
file.exists(input.seqs)
if("DNAStringSet" %in% class(input.seqs)){#
		subject.path <- tempfile()#
		# fa               <- input.seqs#
		# headers          <- names(input.seqs)#
		# contig.names     <- mat.strsplit(headers)[,1]#
		# names(fa)        <- contig.names#
		Biostrings::writeXStringSet(x = subject, filepath=subject.path, append=F, format="fasta")#
		delete.subject <- T#
	} else {#
		if(file.exists(input.seqs)){#
			subject.path   <- input.seqs#
			delete.subject <- F#
		} else {#
			subject.path <- tempfile()#
			# Sets time limit for downloading files to 1000 seconds#
			options(timeout=1000)#
			utils::download.file(url=input.seqs, destfile=subject.path)#
			delete.subject <- T#
		}#
	}
summary(file(input.seqs.path))$class != "gzfile"
input.seqs.path <- subject.path
summary(file(input.seqs.path))$class != "gzfile"
headers        <- Biostrings::fasta.index(input.seqs.path)$desc
length(headers)
fa             <- Biostrings::readDNAStringSet(filepath=input.seqs.path)
contig.names   <- mat.strsplit(headers)[,1]
headers[1]
mat.strsplit(headers)
length(headers)
headers
contig.names   <- gsub(" .+","",headers)
contig.names
names(fa)      <- contig.names
scaff.matches.all  <- match(subject.id, contig.names)
start.all          <- apply(X=cbind(subject.start,subject.end),MARGIN=1,FUN=min)
end.all            <- apply(X=cbind(subject.start,subject.end),MARGIN=1,FUN=max)
subranges          <- IRanges::IRanges(start=start.all ,end=end.all,names=subject.id)
gsubranges         <- GenomicRanges::GRanges(seqnames=subject.id,ranges=subranges)
output.seqs        <- Biostrings::getSeq(fa, gsubranges)
showMethods("getSeq")
?getSeq
output.seqs        <- fa[gsubranges)
output.seqs        <- fa[gsubranges]
?GenomicRanges
library(Biostrings)
output.seqs        <- Biostrings::getSeq(fa, gsubranges)
library(BSgenome)
output.seqs        <- Biostrings::getSeq(fa, gsubranges)
required.packages("BSGenome")
setwd("BSGenome","REEs")
setdiff(required.packages("BSGenome"),required.packages("REEs"))
getSeq
package.load.order("BSGenome")
test <- fa[[gsubranges]]
test <- fa[gsubranges]
test[1]
length(test)
length(output.seqs)
output.seqs[1]
required.packages("Biobase")
required.packages("DelayedArray")
required.packages("GenomicAlignments")
required.packages("MatrixGenerics")
install.packages("MatrixGenerics")
library(BiocManager)
BiocManager::install("MatrixGenerics")
required.packages("matrixStats")
BiocManager::install("rtracklayer")
required.packages("rtracklayer")
required.packages("SummarizedExperiment")
library(REEs)
genomes.dir                  <- "/Users/alyssaleinweber/Documents/genomes/genomes_seqs/"#
Podarcis.muralis.genome_url        <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/004/329/235/GCF_004329235.1_PodMur_1.0/GCF_004329235.1_PodMur_1.0_genomic.fna.gz"#
Lacerta.agilis.genome_url          <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/009/819/535/GCF_009819535.1_rLacAgi1.pri/GCF_009819535.1_rLacAgi1.pri_genomic.fna.gz"#
Zootoca.vivipara.genome_url        <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/011/800/845/GCF_011800845.1_UG_Zviv_1/GCF_011800845.1_UG_Zviv_1_genomic.fna.gz"#
Aspidoscelis.marmoratus.genome_url <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/014/337/955/GCA_014337955.1_AspMar1.0/GCA_014337955.1_AspMar1.0_genomic.fna.gz"#
Salvator.merianae.genome_url       <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/003/586/115/GCA_003586115.2_HLtupMer6/GCA_003586115.2_HLtupMer6_genomic.fna.gz"#
#
Podarcis.muralis.genome_path        <- paste0(genomes.dir,"/",basename(Podarcis.muralis.genome_url))#
Lacerta.agilis.genome_path          <- paste0(genomes.dir,"/",basename(Lacerta.agilis.genome_url))#
Zootoca.vivipara.genome_path        <- paste0(genomes.dir,"/",basename(Zootoca.vivipara.genome_url))#
Aspidoscelis.marmoratus.genome_path <- paste0(genomes.dir,"/",basename(Aspidoscelis.marmoratus.genome_url))#
Salvator.merianae.genome_path       <- paste0(genomes.dir,"/",basename(Salvator.merianae.genome_url))
subject <- Podarcis.muralis.genome_path
subject.path             <- subject#
	subject.obj.temp         <- Biostrings::readDNAStringSet(subject.path)
contigs.name             <- gsub(" .+","",names(subject.obj.temp))#
	subject.path             <- tempfile()
subject.obj.temp2        <- xscat(subject.obj.temp)
subject.obj.temp2
subject.obj.temp
subject.obj.temp2        <- xscat(subject.obj.temp2)
length(subject.obj.temp2)
test <- list(subject.obj.temp2[1],subject.obj.temp2[2])
test
xscat(test)
xscat(subject.obj.temp2[1],subject.obj.temp[2])
26000*35
library(REEs)
Lacerta.agilis_exome         <- Biostrings::readDNAStringSet("/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Lacerta.agilis_exome_longer120bp.fas")
Lacerta.agilis_exome
which(names(Lacerta.agilis_exome)=="NC_046313.1:115413136-115414742")
length(which(table(names(Lacerta.agilis_exome))>1))
length(which(table(names(Lacerta.agilis_exome))==1))
length(table(names(Lacerta.agilis_exome)))
test < distinct(Lacerta.agilis_exome)
test <- distinct(Lacerta.agilis_exome)
test <- unique(Lacerta.agilis_exome)
length(test)
test[1]
test[2]
test[3]
setwd("Documents/REEs")
library(devtools)
devtools::document()
Lacerta.agilis_exome
Lacerta.agilis_exome <- unique(Lacerta.agilis_exome)
Lacerta.agilis_exome
grep("NC_048605.1",names(Lacerta.agilis_exome))
grep("NC_048605.1:.+",names(Lacerta.agilis_exome))
grep("NC_046312.1:7746728-7746896",names(Lacerta.agilis_exome))
538/109589
(538/109589)*100
grep("NC_046312.1:9855207-9855495",names(Lacerta.agilis_exome))
(712/109589)*100
grep("NC_046312.1:11690653-11691030",names(Lacerta.agilis_exome))
(853/109589)*100
grep("NC_046312.1:37013053-37013227",names(Lacerta.agilis_exome))
grep("NC_046313.1:102640361-102640555",names(Lacerta.agilis_exome))
grep("NC_046313.1:115413136-115414742",names(Lacerta.agilis_exome))
grep("NC_046313.1:113347295-113348108",names(Lacerta.agilis_exome))
grep("NC_046313.1:102973441-102973842",names(Lacerta.agilis_exome))
grep("NC_046313.1:81642763-81645522",names(Lacerta.agilis_exome))
grep("NC_046313.1:79948318-79948521",names(Lacerta.agilis_exome))
bt.tiling=0.5;bt.len=120
n.baits=1
(bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))
n.baits=2
120+60
(bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))
180+60
n.baits=3
(bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))
auto.flanking.lengths <- function(locus.len,bt.tiling,bt.len){#
	n.baits <- something... #
	### Starting values for while loop#
	n.baits = 0; bait.coverage.len = 0#
	while(bait.coverage.len < locus.len){#
		n.baits <- n.baits+1#
		bait.coverage.len <- (bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))#
	}#
	bait.coverage.len#
}
auto.flanking.lengths(locus.len=5373,bt.tiling=0.5,bt.len=120)
auto.flanking.lengths <- function(locus.len,bt.tiling,bt.len){#
	### Starting values for while loop#
	n.baits = 0; bait.coverage.len = 0#
	while(bait.coverage.len < locus.len){#
		n.baits <- n.baits+1#
		bait.coverage.len <- (bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))#
	}#
	bait.coverage.len#
}
auto.flanking.lengths(locus.len=5373,bt.tiling=0.5,bt.len=120)
test <- vector()
c(test,1)
c(c(test,1),1)
bait.coverage.vector <- function(longest.locus.len,bt.tiling,bt.len){#
	### Starting values for while loop#
	n.baits = 0; bait.coverage.len = 0#
	result <- vector()#
	while(bait.coverage.len < locus.len){#
		n.baits <- n.baits+1#
		bait.coverage.len <- (bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))#
		result <- c(result,bait.coverage.len)#
	}#
#
	# total.flanking    <- (locus.len-bait.coverage.len)#
	# upstream.len   <- floor(((bait.coverage.len-locus.len)/2))#
	# downstream.len <- target.lengths-(locus.lengths+upstream.lengths)#
}
bait.coverage.vector <- function(longest.locus.len,bt.tiling,bt.len){#
	### Starting values for while loop#
	n.baits = 0; bait.coverage.len = 0#
	result <- vector()#
	while(bait.coverage.len < locus.len){#
		n.baits <- n.baits+1#
		bait.coverage.len <- (bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))#
		result <- c(result,bait.coverage.len)#
	}#
	result#
	# total.flanking    <- (locus.len-bait.coverage.len)#
	# upstream.len   <- floor(((bait.coverage.len-locus.len)/2))#
	# downstream.len <- target.lengths-(locus.lengths+upstream.lengths)#
}
longest.REE.coverage <- bait.coverage.vector(longest.locus.len=7501,bt.tiling=0.5,bt.len=120)
longest.REE.coverage <- bait.coverage.vector(longest.locus.len=7501,bt.tiling=0.5,bt.len=120)ait.coverage.vector <- function(longest.locus.len,bt.tiling,bt.len){#
	### Starting values for while loop#
	locus.len <- longest.locus.len#
	n.baits = 0; bait.coverage.len = 0#
	result <- vector()#
	while(bait.coverage.len < locus.len){#
		n.baits <- n.baits+1#
		bait.coverage.len <- (bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))#
		result <- c(result,bait.coverage.len)#
	}#
	result#
	# total.flanking    <- (locus.len-bait.coverage.len)#
	# upstream.len   <- floor(((bait.coverage.len-locus.len)/2))#
	# downstream.len <- target.lengths-(locus.lengths+upstream.lengths)#
}
ait.coverage.vector <- function(longest.locus.len,bt.tiling,bt.len){#
	### Starting values for while loop#
	locus.len <- longest.locus.len#
	n.baits = 0; bait.coverage.len = 0#
	result <- vector()#
	while(bait.coverage.len < locus.len){#
		n.baits <- n.baits+1#
		bait.coverage.len <- (bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))#
		result <- c(result,bait.coverage.len)#
	}#
	result#
	# total.flanking    <- (locus.len-bait.coverage.len)#
	# upstream.len   <- floor(((bait.coverage.len-locus.len)/2))#
	# downstream.len <- target.lengths-(locus.lengths+upstream.lengths)#
}
longest.REE.coverage <- bait.coverage.vector(longest.locus.len=7501,bt.tiling=0.5,bt.len=120)
bait.coverage.vector <- function(longest.locus.len,bt.tiling,bt.len){#
	### Starting values for while loop#
	locus.len <- longest.locus.len#
	n.baits = 0; bait.coverage.len = 0#
	result <- vector()#
	while(bait.coverage.len < locus.len){#
		n.baits <- n.baits+1#
		bait.coverage.len <- (bt.len+((n.baits-1)*((1-bt.tiling)*bt.len)))#
		result <- c(result,bait.coverage.len)#
	}#
	result#
	# total.flanking    <- (locus.len-bait.coverage.len)#
	# upstream.len   <- floor(((bait.coverage.len-locus.len)/2))#
	# downstream.len <- target.lengths-(locus.lengths+upstream.lengths)#
}
longest.REE.coverage <- bait.coverage.vector(longest.locus.len=7501,bt.tiling=0.5,bt.len=120)
length(longest.REE.coverage)
longest.REE.coverage[1:10]
rev(longest.REE.coverage[1:10)
rev(longest.REE.coverage[1:10])
max(longest.REE.coverage)
growth.len <- ((1-bt.tiling)*bt.len))
growth.len <- ((1-bt.tiling)*bt.len)
growth.len
locus.len
locus.len=7501
bt.len=120
(locus.len-bt.len)/growth.len
bait.coverage.length <- function(locus.len,bt.tiling,bt.len){#
	# Number of additional bases covered after the addition of one more bait#
	growth.len <- ((1-bt.tiling)*bt.len)#
	# baits needed to cover locus#
	num.baits  <- ceiling(((locus.len-bt.len)/growth.len)+1)#
	# bait coverage length#
	bait.coverage        <- num.baits*bt.len#
	names(bait.coverage) <- num.baits#
	bait.coverage#
}
bait.coverage.length(7501,0.5,120)
#' Calculate Bait Coverage and Number of Baits#
#' #
#' Internal function used in pick.loci function.#
#' #
#' @param locus.len Inherited from values in pick.loci function. This is the length of the ith REE locus.#
#' @param bt.tiling Inherited from bait.tiling argument of pick.loci function. This is the fraction of overlap between adjacent baits; value of 0.5 corresponds to 50% overlap between adjacent baits.#
#' @param bt.len Inherited from bait.length argument of pick.loci function. This is the nucleotide length of baits.#
#' @return Named numeric with length of region covered by the minimum number of adjacent baits needed to cover locus.len; names() is equal to the number of baits.#
#' @export bait.coverage.length#
bait.coverage.length <- function(locus.len,bt.tiling,bt.len){#
	# Number of additional bases covered after the addition of one more bait#
	growth.len <- ((1-bt.tiling)*bt.len)#
	# baits needed to cover locus#
	num.baits  <- ceiling(((locus.len-bt.len)/growth.len)+1)#
	# bait coverage length#
	bait.coverage        <- num.baits*bt.len#
	names(bait.coverage) <- num.baits#
	bait.coverage#
}#
#
#' Calculate Flanking Lengths#
#' #
#' Internal function for the pick.loci function; implemented when flanking.length = "auto". Calculates lengths of flanking regions to target for a targetted REE, given the length of the REE, bait length, and bait tiling.#
#' Function is applied to each REE being considered in pick.loci.#
#' #
#' @param locus.length Length of locus.#
#' @param target.length Length of region that includes the locus and is covered by baits.#
#' @return Numerical vector of length two with the number of bases to target immediately upstream and downstream of the locus.#
#' @export auto.flanking.lengths#
auto.flanking.lengths <- function(locus.length,target.length){#
	#total.flanking    <- (locus.len-bait.coverage.len)#
	upstream.len   <- floor((target.length-locus.length)/2)#
	downstream.len <- target.length-(locus.length+upstream.len)#
	result <- c(upstream.len,downstream.len)#
	result#
}
#' Calculate Bait Coverage and Number of Baits#
#' #
#' Internal function used in pick.loci function.#
#' #
#' @param locus.len Inherited from values in pick.loci function. This is the length of the ith REE locus.#
#' @param bt.tiling Inherited from bait.tiling argument of pick.loci function. This is the fraction of overlap between adjacent baits; value of 0.5 corresponds to 50% overlap between adjacent baits.#
#' @param bt.len Inherited from bait.length argument of pick.loci function. This is the nucleotide length of baits.#
#' @return Named numeric with length of region covered by the minimum number of adjacent baits needed to cover locus.len; names() is equal to the number of baits.#
#' @export bait.coverage.length#
bait.coverage.length <- function(locus.len,bt.tiling,bt.len){#
	# Number of additional bases covered after the addition of one more bait#
	growth.len <- ((1-bt.tiling)*bt.len)#
	# baits needed to cover locus#
	num.baits  <- ceiling(((locus.len-bt.len)/growth.len)+1)#
	# bait coverage length#
	bait.coverage        <- num.baits*bt.len#
	names(bait.coverage) <- num.baits#
	bait.coverage#
}#
#
#' Calculate Flanking Lengths#
#' #
#' Internal function for the pick.loci function; implemented when flanking.length = "auto". Calculates lengths of flanking regions to target for a targetted REE, given the length of the REE, bait length, and bait tiling.#
#' Function is applied to each REE being considered in pick.loci.#
#' #
#' @param locus.length Length of locus.#
#' @param target.length Length of region that includes the locus and is covered by baits.#
#' @return Numerical vector of length two with the number of bases to target immediately upstream and downstream of the locus.#
#' @export auto.flanking.lengths#
auto.flanking.lengths <- function(locus.length,target.length){#
	#total.flanking    <- (locus.len-bait.coverage.len)#
	upstream.len   <- floor((target.length-locus.length)/2)#
	downstream.len <- target.length-(locus.length+upstream.len)#
	result <- c(upstream.len,downstream.len)#
	result#
}
auto.flanking.lengths(7501,target.length=bait.coverage.length(7501,0.5,120))
auto.flanking.lengths(locus.length=7501,target.length=bait.coverage.length(7501,0.5,120))
bait.coverage.length <- function(locus.len,bt.tiling,bt.len){#
	# Number of additional bases covered after the addition of one more bait#
	growth.len <- ((1-bt.tiling)*bt.len)#
	# baits needed to cover locus#
	num.baits  <- ceiling(((locus.len-bt.len)/growth.len)+1)#
	# bait coverage length#
	bait.coverage        <- num.baits*bt.len#
	names(bait.coverage) <- num.baits#
	bait.coverage#
}
bait.coverage.length(7501,0.5,120)
bait.coverage.length <- function(locus.len,bt.len,bt.tiling){#
	# Number of additional bases covered after the addition of one more bait#
	growth.len <- ((1-bt.tiling)*bt.len)#
	# baits needed to cover locus#
	num.baits  <- ceiling(((locus.len-bt.len)/growth.len)+1)#
	# bait coverage length#
	bait.coverage        <- ((num.baits-1)*growth.len)+bt.len#
	names(bait.coverage) <- num.baits#
	bait.coverage#
}
bait.coverage.length(7501,120,0.5)
auto.flanking.lengths(7501,bait.coverage.length(7501,120,0.5))
auto.flanking.lengths <- function(locus.len,bt.len,bt.tiling){#
	# Number of additional bases covered after the addition of one more bait#
	growth.len <- ((1-bt.tiling)*bt.len)#
	# baits needed to cover locus#
	num.baits  <- ceiling(((locus.len-bt.len)/growth.len)+1)#
	# bait coverage length#
	bait.coverage        <- ((num.baits-1)*growth.len)+bt.len#
	upstream.len   <- floor((bait.coverage -locus.len)/2)#
	downstream.len <- bait.coverage-(locus.len+upstream.len)#
	result <- c(upstream.len,downstream.len)#
	result#
}
auto.flanking.lengths(7501,120,0.5)
loci.lengths <- sample(x=c(120:7501),size=100,replace=T)
loci.lengths
bait.coverage.length(locus.len=loci.lengths,bt.len=120,bt.tiling=0.5)
loci.bait.coverage.lengths         <- bait.coverage.length(locus.len=loci.lengths,bt.len=120,bt.tiling=0.5)#
	loci.num.baits                     <- names(loci.bait.coverage.lengths)
loci.num.baits
loci.num.baits                     <- as.numeric(names(loci.bait.coverage.lengths))
loci.num.baits
bait.length=120
bait.tiling=0.5
loci.flanking.lengths <- auto.flanking.lengths(locus.len=loci.lengths,bt.len=bait.length,bt.tiling=bait.tiling)
loci.flanking.lengths
auto.flanking.lengths <- function(locus.len,bt.len,bt.tiling){#
	# Number of additional bases covered after the addition of one more bait#
	growth.len <- ((1-bt.tiling)*bt.len)#
	# baits needed to cover locus#
	num.baits  <- ceiling(((locus.len-bt.len)/growth.len)+1)#
	# bait coverage length#
	bait.coverage        <- ((num.baits-1)*growth.len)+bt.len#
	upstream.len   <- floor((bait.coverage -locus.len)/2)#
	downstream.len <- bait.coverage-(locus.len+upstream.len)#
	result <- list(upstream.len,downstream.len)#
	result#
}
loci.flanking.lengths <- auto.flanking.lengths(locus.len=loci.lengths,bt.len=bait.length,bt.tiling=bait.tiling)
loci.flanking.lengths
loci.upstream.flanking.lengths   <- auto.flanking.lengths(locus.len=loci.lengths,bt.len=bait.length,bt.tiling=bait.tiling)[[1]]#
			loci.downstream.flanking.lengths <- auto.flanking.lengths(locus.len=loci.lengths,bt.len=bait.length,bt.tiling=bait.tiling)[[2]]
loci.upstream.flanking.lengths
loci.downstream.flanking.lengths
auto.flanking.lengths <- function(locus.len,bt.len,bt.tiling){#
	# Number of additional bases covered after the addition of one more bait#
	growth.len <- ((1-bt.tiling)*bt.len)#
	# baits needed to cover locus#
	num.baits  <- ceiling(((locus.len-bt.len)/growth.len)+1)#
	# bait coverage length#
	bait.coverage        <- ((num.baits-1)*growth.len)+bt.len#
	upstream.len   <- floor((bait.coverage -locus.len)/2)#
	downstream.len <- bait.coverage-(locus.len+upstream.len)#
	result <- list(upstream.len,downstream.len)#
	names(result) <- c("upstream","downstream")#
	result#
}
loci.flanking.lengths.list       <- auto.flanking.lengths(locus.len=loci.lengths,bt.len=bait.length,bt.tiling=bait.tiling)#
			loci.upstream.flanking.lengths   <- loci.flanking.lengths.list[[1]]#
			loci.downstream.flanking.lengths <- loci.flanking.lengths.list[[2]]
loci.flanking.lengths.list
loci.upstream.flanking.lengths
loci.downstream.flanking.lengths
flanking.length=100
loci.lengths.with.flanking <- loci.lengths+(2*flanking.length)
loci.lengths.with.flanking
loci.num.baits             <- as.numeric(names(loci.lengths.with.flanking))
loci.num.baits
loci.bait.coverage.lengths <- bait.coverage.length(locus.len=loci.lengths.with.flanking,bt.len=bait.length,bt.tiling=bait.tiling)
loci.bait.coverage.lengths
loci.num.baits             <- as.numeric(names(loci.lengths.with.flanking))
locu.num.baits
loci.num.baits
loci.num.baits             <- as.numeric(names(loci.lengths.with.flanking))
loloci.num.baits             <- as.numeric(names(loci.bait.coverage.lengths))
loci.num.baits             <- as.numeric(names(loci.bait.coverage.lengths))
loci.num.baits
grep("NC_046313.1:66038313-66038747",names(Lacerta.agilis.exome))
grep("NC_046313.1:66038313-66038747",names(Lacerta.agilis_exome))
length(Lacerta.agilis_exome)
15838/length(Lacerta.agilis_exome)
setwd()
getwd()
library(devtools)
devtools::document()
rm(list = c("auto.flanking.lengths", "bait.coverage.length"))
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::document()
devtools::build()
devtools::install()
