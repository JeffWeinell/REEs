IRanges::IRanges(start=base.to.mutate.i)
seq.to.mutate <- sample(1:length(input.seqs),size=n.deletions,replace=T)#
	# numerical vector indicating where each deletion will begin#
	base.to.mutate <- sapply(X=width(input.seqs[seq.to.mutate]),FUN=function(x){sample(c(1:x),size=1)})#
	# numerical vector indicating the length of each deletion#
	length.deletions <- sample(c(min(length.lim):max(length.lim)),size=n.deletions,replace=T)#
	### Character matrix with three rows and n.deletions columns; each column contains the three nucleotide bases that are different from the current one.#
	### change.to.mat  <- mapply(FUN=function(A,B){setdiff(c("A","C","G","T"),subseq(input.seqs[A],start=B,width=1))},A=seq.to.mutate,B=base.to.mutate)#
	### Characer vector indicating th#
	# change.to.vect <- sapply(X=1:ncol(change.to.mat),FUN=function(x){sample(change.to.mat[,x],size=1)})#
	### Add length.lim[2] "-" sites to the 3' end of each sequence in input.seqs, so proposed deletion sites are not outside the range of sites possible. The added sites will be removed later.#
	buffer.region <- Biostrings::DNAStringSet(x=rep(paste0(rep("-",length.lim[2]),collapse=""),length(input.seqs)))#
	input.seqs2   <- Biostrings::xscat(input.seqs,buffer.region)
input.seqs2
for(i in 1:n.deletions){#
		seq.to.mutate.i              <- seq.to.mutate[i]#
		base.to.mutate.i             <- base.to.mutate[i]#
		length.deletions.i           <- length.deletions[i]#
		input.seqs2[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs2[seq.to.mutate.i],at=IRanges::IRanges(start=base.to.mutate.i),value=paste(rep("-",length.deletions.i),collapse=""))#
	}
input.seqs2
seq.to.mutate <- sample(1:length(input.seqs),size=n.deletions,replace=T)#
	# numerical vector indicating where each deletion will begin#
	base.to.mutate <- sapply(X=width(input.seqs[seq.to.mutate]),FUN=function(x){sample(c(1:x),size=1)})#
	# numerical vector indicating the length of each deletion#
	length.deletions <- sample(c(min(length.lim):max(length.lim)),size=n.deletions,replace=T)#
	### Character matrix with three rows and n.deletions columns; each column contains the three nucleotide bases that are different from the current one.#
	### change.to.mat  <- mapply(FUN=function(A,B){setdiff(c("A","C","G","T"),subseq(input.seqs[A],start=B,width=1))},A=seq.to.mutate,B=base.to.mutate)#
	### Characer vector indicating th#
	# change.to.vect <- sapply(X=1:ncol(change.to.mat),FUN=function(x){sample(change.to.mat[,x],size=1)})#
	### Add length.lim[2] "-" sites to the 3' end of each sequence in input.seqs, so proposed deletion sites are not outside the range of sites possible. The added sites will be removed later.#
	buffer.region <- Biostrings::DNAStringSet(x=rep(paste0(rep("-",length.lim[2]),collapse=""),length(input.seqs)))#
	input.seqs2   <- Biostrings::xscat(input.seqs,buffer.region)
input.seqs2
for(i in 1:n.deletions){#
		seq.to.mutate.i              <- seq.to.mutate[i]#
		base.to.mutate.i             <- base.to.mutate[i]#
		length.deletions.i           <- length.deletions[i]#
		input.seqs2[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs2[seq.to.mutate.i],at=IRanges::IRanges(start=base.to.mutate.i,width=length.deletions.i),value=paste(rep("-",length.deletions.i),collapse=""))#
	}
input.seqs2
result <- Biostrings::subseq(input.seqs2,start=1,end=width(input.seqs))
result
format=""
format==""
seq.to.mutate <- sample(1:length(input.seqs),size=n.deletions,replace=T)#
	# numerical vector indicating where each deletion will begin#
	base.to.mutate <- sapply(X=width(input.seqs[seq.to.mutate]),FUN=function(x){sample(c(1:x),size=1)})#
	# numerical vector indicating the length of each deletion#
	length.deletions <- sample(c(min(length.lim):max(length.lim)),size=n.deletions,replace=T)#
	### Character matrix with three rows and n.deletions columns; each column contains the three nucleotide bases that are different from the current one.#
	### change.to.mat  <- mapply(FUN=function(A,B){setdiff(c("A","C","G","T"),subseq(input.seqs[A],start=B,width=1))},A=seq.to.mutate,B=base.to.mutate)#
	### Characer vector indicating th#
	# change.to.vect <- sapply(X=1:ncol(change.to.mat),FUN=function(x){sample(change.to.mat[,x],size=1)})#
	### Add length.lim[2] "-" sites to the 3' end of each sequence in input.seqs, so proposed deletion sites are not outside the range of sites possible. The added sites will be removed later.#
	buffer.region <- Biostrings::DNAStringSet(x=rep(paste0(rep("-",length.lim[2]),collapse=""),length(input.seqs)))#
	input.seqs2   <- Biostrings::xscat(input.seqs,buffer.region)
input.seqs2[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs2[seq.to.mutate.i],at=IRanges::IRanges(start=base.to.mutate.i,width=length.deletions.i),value="")
input.seqs2
for(i in 1:n.deletions){#
		seq.to.mutate.i              <- seq.to.mutate[i]#
		base.to.mutate.i             <- base.to.mutate[i]#
		length.deletions.i           <- length.deletions[i]#
		input.seqs2[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs2[seq.to.mutate.i],at=IRanges::IRanges(start=base.to.mutate.i,width=length.deletions.i),value=paste(rep("-",length.deletions.i),collapse=""))#
	}
input.seqs2
format=""
result <- DECIPHER::RemoveGaps(input.seqs2)
result
result <- DECIPHER::RemoveGaps(input.seqs2)
random.insertions <- function(input.seqs,n.insertions,length.lim=1){#
	# numerical vector with length n.insertions; ith entry indicates which sequence will get the ith deletion#
	seq.to.mutate    <- sample(1:length(input.seqs),size=n.insertions,replace=T)#
	# numerical vector indicating the length of each deletion#
	length.insertions <- sample(c(min(length.lim):max(length.lim)),size=n.insertions,replace=T)#
	for(i in 1:n.insertions){#
		seq.to.mutate.i             <- seq.to.mutate[i]#
		# Where ith insertion will occur#
		base.to.mutate.i            <- sample(c(1:width(input.seqs[seq.to.mutate.i])),size=1)#
		length.insertions.i         <- length.insertions[i]#
		# Sequence that should be inserted#
		insertion.seq.i             <- paste(sample(c("A","C","G","T"),size=length.insertions.i,replace=T),collapse="")#
		input.seqs[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs[seq.to.mutate.i],at=base.to.mutate.i,value=insertion.seq.i)#
	}#
	result <- input.seqs#
	result#
}
random.insertions(input.seqs=Lacerta.agilis_exome[1:5],n.insertions=5)
Lacerta.agilis_exome[1:5]
sum(width(Lacerta.agilis_exome[1:5]))
sum(width(random.insertions(input.seqs=Lacerta.agilis_exome[1:5],n.insertions=5)))
reverse("ACGT")
random.inversions <- function(input.seqs,n.inversions,length.lim){#
	# numerical vector with length n.inversions; ith entry indicates which sequence will get the ith deletion#
	seq.to.mutate    <- sample(1:length(input.seqs),size=n.inversions,replace=T)#
	# numerical vector indicating the length of each deletion#
	length.inversions <- sample(c(min(length.lim):max(length.lim)),size=n.inversions,replace=T)#
	for(i in 1:n.inversions){#
		seq.to.mutate.i             <- seq.to.mutate[i]#
		# Where ith inversions will occur#
		base.to.mutate.i            <- sample(c(1:width(input.seqs[seq.to.mutate.i])),size=1)#
		length.inversions.i         <- length.inversions[i]#
		# Sequence that should be inserted#
		inversions.seq.i            <- reverse(Biostrings::subseq(input.seqs[seq.to.mutate.i],start=base.to.mutate.i,width=length.inversions.i))#
		input.seqs[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs[seq.to.mutate.i],at=IRanges::IRanges(start=base.to.mutate.i,width=length.inversions.i),value=inversions.seq.i)#
	}#
	result <- input.seqs#
	result#
}
random.inversions(input.seqs=Lacerta.agilis_exome[1:5],n.inversions=5,length.lim=c(5,5))
random.transpositions <- function(input.seqs,n.transpositions=1,length.lim){#
	# numerical vector with length n.transpositions; ith entry indicates which sequence will get the ith deletion#
	seq.to.mutate    <- sample(1:length(input.seqs),size=n.transpositions,replace=T)#
	# numerical vector indicating the length of each deletion#
	length.transpositions <- sample(c(min(length.lim):max(length.lim)),size=n.transpositions,replace=T)#
	for(i in 1:n.transpositions){#
		seq.to.mutate.i             <- seq.to.mutate[i]#
		# Where ith transposed region occurs initially#
		base.to.mutate.i            <- sample(c(1:width(input.seqs[seq.to.mutate.i])),size=1)#
		length.transpositions.i     <- length.inversions[i]#
		# Where ith transposed region will be inserted#
		final.position.i            <- sample(c(1:width(input.seqs[seq.to.mutate.i])),size=1)#
		# Sequence of transposed region#
		transpositions.seq.i        <- Biostrings::subseq(input.seqs[seq.to.mutate.i],start=base.to.mutate.i,width=length.transpositions.i)#
		# Remove transposed region from its origional location#
		input.seqs[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs[seq.to.mutate.i],at=IRanges::IRanges(start=base.to.mutate.i,width=length.inversions.i),value="-")#
		# Insert transposed region into its new location#
		input.seqs[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs[seq.to.mutate.i],at=final.position.i,value=transpositions.seq.i)#
	}#
	result <- input.seqs#
	result#
}
random.transpositions(input.seqs=Lacerta.agilis_exome[1:5],length.lim=c(50,50))
random.transpositions <- function(input.seqs,n.transpositions=1,length.lim){#
	# numerical vector with length n.transpositions; ith entry indicates which sequence will get the ith deletion#
	seq.to.mutate    <- sample(1:length(input.seqs),size=n.transpositions,replace=T)#
	# numerical vector indicating the length of each deletion#
	length.transpositions <- sample(c(min(length.lim):max(length.lim)),size=n.transpositions,replace=T)#
	for(i in 1:n.transpositions){#
		seq.to.mutate.i             <- seq.to.mutate[i]#
		# Where ith transposed region occurs initially#
		base.to.mutate.i            <- sample(c(1:width(input.seqs[seq.to.mutate.i])),size=1)#
		length.transpositions.i     <- length.transpositions[i]#
		# Where ith transposed region will be inserted#
		final.position.i            <- sample(c(1:width(input.seqs[seq.to.mutate.i])),size=1)#
		# Sequence of transposed region#
		transpositions.seq.i        <- Biostrings::subseq(input.seqs[seq.to.mutate.i],start=base.to.mutate.i,width=length.transpositions.i)#
		# Remove transposed region from its origional location#
		input.seqs[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs[seq.to.mutate.i],at=IRanges::IRanges(start=base.to.mutate.i,width=length.transpositions.i),value="-")#
		# Insert transposed region into its new location#
		input.seqs[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs[seq.to.mutate.i],at=final.position.i,value=transpositions.seq.i)#
	}#
	result <- input.seqs#
	result#
}
random.transpositions(input.seqs=Lacerta.agilis_exome[1:5],length.lim=c(50,50))
random.transpositions <- function(input.seqs,n.transpositions=1,length.lim){#
	# numerical vector with length n.transpositions; ith entry indicates which sequence will get the ith deletion#
	seq.to.mutate    <- sample(1:length(input.seqs),size=n.transpositions,replace=T)#
	# numerical vector indicating the length of each deletion#
	length.transpositions <- sample(c(min(length.lim):max(length.lim)),size=n.transpositions,replace=T)#
	for(i in 1:n.transpositions){#
		seq.to.mutate.i             <- seq.to.mutate[i]#
		# Where ith transposed region occurs initially#
		base.to.mutate.i            <- sample(c(1:width(input.seqs[seq.to.mutate.i])),size=1)#
		length.transpositions.i     <- length.transpositions[i]#
		# Where ith transposed region will be inserted#
		final.position.i            <- sample(c(1:width(input.seqs[seq.to.mutate.i])),size=1)#
		# Sequence of transposed region#
		transpositions.seq.i        <- Biostrings::subseq(input.seqs[seq.to.mutate.i],start=base.to.mutate.i,width=length.transpositions.i)#
		# Remove transposed region from its origional location#
		input.seqs[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs[seq.to.mutate.i],at=IRanges::IRanges(start=base.to.mutate.i,width=length.transpositions.i),value=paste(rep("-",length.transpositions.i),collapse=""))#
		# Insert transposed region into its new location#
		input.seqs[seq.to.mutate.i] <- Biostrings::replaceAt(input.seqs[seq.to.mutate.i],at=final.position.i,value=transpositions.seq.i)#
	}#
	result <- input.seqs#
	result#
}
random.transpositions(input.seqs=Lacerta.agilis_exome[1:5],length.lim=c(50,50))
test <- matrix(data="text",nrow=3,ncol=3,mode="character")
mode(test)
test <- matrix(data="text",nrow=3,ncol=3)
test
mode(test)
is(test,"character")
class(test)
test2 <- as.data.table(test)
test2
is(test2,"data.frame")
class(test2)
Podarcis.muralis_GFF.url <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/004/329/235/GCF_004329235.1_PodMur_1.0/GCF_004329235.1_PodMur_1.0_genomic.gff.gz"
input.gff <- Podarcis.muralis_GFF.url
input.gff
is(input.gff,"character")
file.exists(input.gff)
temp.name <- tempfile()
temp.name
utils::download.file(input.gff,dest=temp.name,quiet=T)
Line1 <- readLines(temp.name,n=1)
nchar(Line1)
Line1
".+gff-version .+" %in% Line1
grep("gff-version",Line1)
?grep("gff-version",Line1)
any(grep("gff-version",Line1))
any(grep("ridiculous",Line1))
any(grep("gff-version",Line1))
gff.obj   <- ape::read.gff(temp.name, na.strings = c(".", "?"), GFF3 = TRUE)
class(gff.obj)
invisible(file.remove(temp.name))
gff.obj <- data.table::as.data.table(gff.obj)
gff.obj
load.gff <- function(input.gff){#
	if(is(input.gff,"character")){#
		if(file.exists(input.gff)){#
			### Check first line of file to determine if it is a GFF-like table or an actual GFF file (with a GFF header)#
			Line1 <- readLines(input.gff,n=1)#
			if(any(grep("gff-version",Line1))){#
				### Read GFF using ape function read.gff#
				gff.obj <- ape::read.gff(input.gff, na.strings = c(".", "?"), GFF3 = TRUE)#
			} else {#
				### Read the GFF as a data.table object and then coerce it to a data frame.#
				gff.obj <- data.table::fread(input.gff)#
			}#
		} else {#
			### Creates a path (character string) that the GFF will be saved to #
			temp.name <- tempfile()#
			### Downloads the GFF to temp.name#
			utils::download.file(input.gff,dest=temp.name,quiet=T)#
			### Now check if the downloaded file is a GFF-like table or an actual GFF file (with a GFF header)#
			Line1 <- readLines(temp.name,n=1)#
			if(any(grep("gff-version",Line1))){#
				# Reads the GFF into R as a data.frame object#
				gff.obj   <- ape::read.gff(temp.name, na.strings = c(".", "?"), GFF3 = TRUE)#
				# Removes the temporary file#
				invisible(file.remove(temp.name))#
			} else {#
				gff.obj <- data.table::fread(temp.name)#
			}#
		}#
	} else {#
		if(is(input.gff,"data.frame") | is(input.gff,"matrix")){#
			gff.obj   <- input.gff#
		} else {#
			stop("input.gff has unrecognized format")#
		}#
	}#
	### Coerce to data.table object#
	gff.obj <- data.table::as.data.table(gff.obj)#
	gff.obj#
}
load.gff(Podarcis.muralis_GFF.url)
colnames(gff.obj)
unfiltered.gff   <- as.data.frame(gff.obj)
unfiltered.gff[1:10,]
mode(unfiltered.gff[,1])
unfiltered.gff[,1][1:10]
is.numeric(unfiltered.gff[,1])
mode(unfiltered.gff[,1])
sapply(stats.table0[, numeric.columns], mode)
test <- sapply(unfiltered.gff, mode)
length(test)
test
numeric.columns <- which(colnames(unfiltered.gff) %in% c("start","end"))
numeric.columns
unfiltered.gff[, numeric.columns] <- sapply(unfiltered.gff[, numeric.columns], as.numeric)
character.columns <- which(!(colnames(unfiltered.gff) %in% c("start","end")))
character.columns
unfiltered.gff[, character.columns] <- sapply(unfiltered.gff[, character.columns], as.character)
unfiltered.gff[1:10,]
test <- sapply(unfiltered.gff, mode)
test
length(which(unfiltered.gff[,3]==feature.type))
feature.type="CDS"
length(which(unfiltered.gff[,3]==feature.type))
length(which(unfiltered.gff[,3]=="gene"))
filtered.gff1A   <- unfiltered.gff[which(unfiltered.gff[,3]==feature.type),]
nrow(filtered.gff1A)
widths1A         <- abs(as.numeric(filtered.gff1A$start)-as.numeric(filtered.gff1A$end))
length(widths1A )
widths1A[1]
widths1A[2]
test <- sapply(filtered.gff1A, mode)
test
widths1A[1:10]
widths1A         <- abs(filtered.gff1A$start-filtered.gff1A$end)
widths1A[1:10]
widths1A         <- (abs(filtered.gff1A$start-filtered.gff1A$end))+1
widths1A[1:10]
min.length=120
filtered.gff1B   <- filtered.gff1A[which(widths1A>=min.length),]
nrow(filtered.gff1B)
load.gff <- function(input.gff){#
	if(is(input.gff,"character")){#
		if(file.exists(input.gff)){#
			### Check first line of file to determine if it is a GFF-like table or an actual GFF file (with a GFF header)#
			Line1 <- readLines(input.gff,n=1)#
			if(any(grep("gff-version",Line1))){#
				### Read GFF using ape function read.gff#
				gff.obj <- ape::read.gff(input.gff, na.strings = c(".", "?"), GFF3 = TRUE)#
			} else {#
				### Read the GFF as a data.table object and then coerce it to a data frame.#
				gff.obj <- data.table::fread(input.gff)#
			}#
		} else {#
			### Creates a path (character string) that the GFF will be saved to #
			temp.name <- tempfile()#
			### Downloads the GFF to temp.name#
			utils::download.file(input.gff,dest=temp.name,quiet=T)#
			### Now check if the downloaded file is a GFF-like table or an actual GFF file (with a GFF header)#
			Line1 <- readLines(temp.name,n=1)#
			if(any(grep("gff-version",Line1))){#
				# Reads the GFF into R as a data.frame object#
				gff.obj   <- ape::read.gff(temp.name, na.strings = c(".", "?"), GFF3 = TRUE)#
				# Removes the temporary file#
				invisible(file.remove(temp.name))#
			} else {#
				gff.obj <- data.table::fread(temp.name)#
			}#
		}#
	} else {#
		if(is(input.gff,"data.frame") | is(input.gff,"matrix")){#
			gff.obj   <- input.gff#
		} else {#
			stop("input.gff has unrecognized format")#
		}#
	}#
	### Coerce to data.table object#
	gff.obj <- data.table::as.data.table(gff.obj)#
	gff.obj#
}
input.gff="/Users/alyssaleinweber/Downloads/Lacerta.agilis_GFF_CDS_longer120bp.txt"
x <- input.gff
filtered.gff1B <- as.data.frame(load.gff(x))
class(filtered.gff1B)
filtered.gff1B <- load.gff(x)
class(filtered.gff1B)
filtered.gff1B
filtered.gff1B <- as.data.frame(load.gff(x))
test <- sapply(filtered.gff1B, mode)
test
numeric.columns <- which(colnames(filtered.gff1B) %in% c("start","end"))
numeric.columns
filtered.gff1B[, numeric.columns] <- sapply(filtered.gff1B[, numeric.columns], as.numeric)
character.columns <- which(!(colnames(filtered.gff1B) %in% c("start","end")))
filtered.gff1B[, character.columns] <- sapply(filtered.gff1B[, character.columns], as.character)
sapply(filtered.gff1B, mode)
refseq.names   <- unlist(filtered.gff1B[,1])
refseq.names[1]
additional.ID
additional.ID<-NULL
!is.null(additional.ID)
subject.id       <- refseq.names
subject.start    <- filtered.gff1B$start
subject.end      <- filtered.gff1B$end
new.names        <- paste0(refseq.names,":",subject.start,"-",subject.end)
new.names[1]
new.names[2]
Lacerta.agilis_exome <- Biostrings::readDNAStringSet(filepath="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Lacerta.agilis_exome_longer120bp.fas")
grep("NC_046312.1:84060818-84061670",names(Lacerta.agilis_exome))
grep("NC_046319.1:36771841-36772193",names(Lacerta.agilis_exome))
57111/length(Lacerta.agilis_exome)
6563/length(Lacerta.agilis_exome)
grep("NC_046312.1:81680187-81681417",names(Lacerta.agilis_exome))
6089/length(Lacerta.agilis_exome)
grep("NC_046313.1:104728512-104728660",names(Lacerta.agilis_exome))
18603/length(Lacerta.agilis_exome)
?data.table()
?fread()
library(REEs)
input.seqs = c("/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Crotalus.horridus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Ophiophagus.hannah.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Pantherophis.guttatus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Thamnophis.sirtalis.tblastx.best.hits_seqs.fas")#
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")#
reference.species = 4#
input.gff = NULL; output.path = NULL, alignments.out=NULL; subgroup=NULL; i.start=1; i.stop=NA; mafft.params="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6"
input.seqs = c("/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Crotalus.horridus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Ophiophagus.hannah.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Pantherophis.guttatus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Thamnophis.sirtalis.tblastx.best.hits_seqs.fas")#
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")#
reference.species = 4#
input.gff = NULL; output.path = NULL; alignments.out=NULL; subgroup=NULL; i.start=1; i.stop=NA; mafft.params="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6"
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ",".","-"),c("_","_","_"),species)
species
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","\.","-"),c("_","_","_"),species)
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","/.","-"),c("_","_","_"),species)
species
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)
species
species.names = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")
species  <- c(species.names[reference.species],species.names[-reference.species])
species
species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)
species
species  <- c(species.names[reference.species],species.names[-reference.species])#
	species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)#
	if(is.null(subgroup)){#
		subgroup <- species#
	}#
	if(is.null(output.path)){#
		output.path <- tempfile()#
		delete <- T#
	} else {#
		delete <- F#
	}
species
if(!is.null(alignments.out)){#
		dir.check.create(alignments.out)#
	}
is.subgroup     <- mgrep(query=subgroup,subject=species)
is.subgroup
is(input.seqs[[1]],"character")
input.seqs   <- c(input.seqs[reference.species],input.seqs[-reference.species])
input.seqs
species.seqs <- lapply(X=input.seqs,FUN=function(x){Biostrings::readDNAStringSet(x)})
if(is(input.seqs[[1]],"character")){#
		### Puts the input.seqs in the same order as species.#
		input.seqs   <- c(input.seqs[reference.species],input.seqs[-reference.species])#
		### Read in the sequences for each species as a DNAStringSet, and hold the set of DNAStringSets in a list#
		# Important not to name each DNAStringSet in the list#
		species.seqs <- lapply(X=input.seqs,FUN=function(x){Biostrings::readDNAStringSet(x)})#
	} else { #
		if(is(input.seqs[[1]],"DNAStringSet")){#
			##### Important not to name each DNAStringSet in the list#
			### Puts the input.seqs in the same order as species.#
			input.seqs        <- input.seqs[c(reference.species,c(1:length(input.seqs))[-reference.species])]#
			### Set species.seqs equal to input.seqs in this case.#
			species.seqs <- input.seqs#
		}#
		else {#
			stop("input.seqs must be a list of DNAStringSet objects or a vector of character strings with filepaths to sequences in fasta format")#
		}#
	}
length(species.seqs)
matches.list    <- lapply(X=species.seqs,FUN=function(x){ gsub("_Subject=.*","",names(x))})
length(matches.list)
all.loci        <- unique(unlist(matches.list))
matches.indices.all         <- lapply(X=matches.list,FUN=function(y){match(x=all.loci,table=y)})
species.seqs.all            <- mapply(FUN=function(X,Y){Z=Y[which(!is.na(Y))];X[Z]},X=species.seqs,Y=matches.indices.all,SIMPLIFY=F)
CDS.locus.identifier.all    <- mgsub(c(":","-"),c("_","_"),all.loci)
length(CDS.locus.identifier.all)
CDS.locus.identifier.all[1]
CDS.locus.identifier.all[2]
CDS.locus.identifier.all[3]
loci.ranges.all  <- mgsub(c(".*\\.1:","-"),c("","_"),all.loci)
loci.ranges.all[1]
length(all.loci)
all.loci[1]
mgsub(c(".*\\.1:","-"),c("","_"),all.loci[1])
mgsub(c(".+\\.1:","-"),c("","_"),all.loci[1])
mgsub(c("^.+\\.1:","-"),c("","_"),all.loci[1])
mgsub(c("^.+\\.1.","-"),c("","_"),all.loci[1])
loci.ranges.all  <- mgsub(c(".*\\.1.","-","_Gene=.+"),c("","_",""),all.loci)
loci.ranges.all[1]
loci.lengths.all <- (abs(as.numeric(gsub(".*_","",loci.ranges.all))-as.numeric(gsub("_.*","",loci.ranges.all)))+1)
loci.lengths.all[1]
1014392-1014266
is.null(input.gff)
length(all.loci)
gene.names.all <- rep(NA,length(all.loci))
if(is.na(i.start) | i.start > length(all.loci)){#
		### Default i.start, ie which exons to start the loop at#
		i.start <- 1#
	}#
	if(is.na(i.stop) | i.stop > length(all.loci)){#
		### Default i.stop, ie which exons to stop the loop at#
		i.stop  <- length(all.loci)#
	}
i.start
i.stop
index.matrix.all            <- do.call(rbind, matches.indices.all)
index.matrix.all
if(!is.null(names(species.seqs.all))){#
		names(species.seqs.all) <- NULL#
	}
temp.seqs.all               <- lapply(c(1:ncol(index.matrix.all)),function(input){do.call(c,mapply(FUN=function(A,B){C=B[which(!is.na(B))];A[C]},A=species.seqs.all,B=lapply(X=index.matrix.all[,input],FUN=function(x){x})))})
length(species.seqs.all)
species.seqs.all[[1]]
class(index.matrix.all)
mode(index.matrix.all)
length(index.matrix.all)
index.matrix.all[,1]
test = index.matrix.all[,1]
lapply(X=test, FUN=function(x){x})
as.list(test)
length(species.seqs.all)
which(!is.na(as.list(test)))
as.list(test)[which(!is.na(as.list(test)))]
species.seqs.all[as.list(index.matrix.all[,1])[which(!is.na(as.list(index.matrix.all[,1])))]]
organize.seqs.by.locus <- function(species.seqs,index.matrix){#
	num.loci <- 1:ncol(index.matrix)#
	lapply(X=1:num.loci,FUN=function(i){do.call(c,mapply(FUN=function(A,B){C=B[which(!is.na(B))]; A[C]}, A=species.seqs, B=as.list(index.matrix[,i])))})#
}
test <- organize.seqs.by.locus(species.seqs=species.seqs.all,index.matrix=index.matrix.all)
length(temp.seqs.all)
temp.seqs.all[1]
names.temp.seqs.all         <- apply(X=index.matrix.all,MARGIN=2,FUN=function(input){species[!is.na(input)]})
length(names.temp.seqs.all)
if(is(names.temp.seqs.all,"list")){#
		for(i in 1:length(temp.seqs.all)){#
			names(temp.seqs.all[[i]]) <- names.temp.seqs.all[[i]]#
		}#
	}#
	if(is(names.temp.seqs.all,"matrix")){#
		for(i in 1:length(temp.seqs.all)){#
			names(temp.seqs.all[[i]]) <- names.temp.seqs.all[,i]#
		}#
	}
tempMatrix.all           <- matrix(data=0, nrow=length(1:length(all.loci)), ncol=12+length(species))
tempMatrix.all
colnames(tempMatrix.all) <- c(paste0(species[1],".locus"), "num.Species","CountCover","absolutePIS","percentPIS","mean.pident", paste0("pident.",species), "gene.name",paste0("locus.length.",species[1]),"mean.variable.sites","min.pident.all","min.pident.subgroup","alignment.width")#
	tempMatrix.all[,1]             <- all.loci
nrow(tempMatrix.all)
length(gene.names.all)
gene.names.all[1]
colnames(tempMatrix.all) <- c(paste0(species[1],".locus"), "num.Species","CountCover","absolutePIS","percentPIS","mean.pident", paste0("pident.",species), "gene.name",paste0("locus.length.",species[1]),"mean.variable.sites","min.pident.all","min.pident.subgroup","alignment.width")#
	tempMatrix.all[,1]             <- all.loci#
	tempMatrix.all[,"gene.name"]   <- gsub("gene=","",gene.names.all)#
	tempMatrix.all[,"num.Species"] <- sapply(temp.seqs.all,length)
tempMatrix.all[1:10,]
# Find which column is the gene.name column#
	which.is.gene.name.column <- which(colnames(tempMatrix.all)=="gene.name")#
	# Columns that should be character mode#
	character.columns <- c(1,which.is.gene.name.column)#
	# Columns that should be numeric mode#
	numeric.columns   <- setdiff(1:ncol(tempMatrix.all),character.columns)#
	# Set the mode to numeric for those columns that should be numeric#
	tempMatrix.all[, numeric.columns] <- sapply(tempMatrix.all[, numeric.columns], as.numeric)
tempMatrix.all[1:10,]
class(tempMatrix.all)
tempMatrix.all[,1]             <- all.loci#
	tempMatrix.all[,"gene.name"]   <- gsub("gene=","",gene.names.all)#
	tempMatrix.all[,"num.Species"] <- sapply(temp.seqs.all,length)
tempMatrix   <- tempMatrix.all#
	temp.seqs    <- temp.seqs.all#
	loci.lengths <- loci.lengths.all
i=1
if (as.numeric(tempMatrix[i,"num.Species"])>1){#
			### aligns the ith locus of each species#
#			alignment.temp              <- REEs::mafft(temp.seqs[[i]],param="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6")#
			alignment.temp              <- REEs::mafft(temp.seqs[[i]],param=mafft.params)#
			### Number of sites in alignment#
			alignment.width             <- width(alignment.temp)[1]#
			### pairwise matrix of absolute genetic distance#
			distances                   <- 100*as.matrix(ape::dist.dna(ape::as.DNAbin(alignment.temp),model="raw",pairwise.deletion=T))#
			### Alternative method for calculating genetic distances. Doesnt seem any faster than the ape method.#
			# distances <- (100*(Biostrings::stringDist(alignment.temp)/alignment.width))#
			### pairwise matrix of percent genetic identity#
			pident                      <- round(100-distances,digits=2)#
			mean.pident                 <- round(mean(pident[1,-1]),digits=2)#
			### mean percent identity of the primary species to each of the other species.#
			tempMatrix[i,"mean.pident"] <- mean.pident#
			### percent identity of the primary species to each species in the alignment (including itself, with should be 100% idendical).#
			tempMatrix[i,(7:(length(species)+6))[species %in% names(alignment.temp)]] <- pident[1,]#
			if(any(!species %in% names(alignment.temp))){#
				tempMatrix[i,(7:(length(species)+6))[!species %in% names(alignment.temp)]] <- NA#
			}#
		}
setwd("Documents/REEs")
devtools::document()
library(devtools)
devtools::document()
devtools::document()
