filtered.gff1B   <- filtered.gff1A[which(widths1A>=min.length),]
nrow(filtered.gff1B)
load.gff <- function(input.gff){#
	if(is(input.gff,"character")){#
		if(file.exists(input.gff)){#
			### Check first line of file to determine if it is a GFF-like table or an actual GFF file (with a GFF header)#
			Line1 <- readLines(input.gff,n=1)#
			if(any(grep("gff-version",Line1))){#
				### Read GFF using ape function read.gff#
				gff.obj <- ape::read.gff(input.gff, na.strings = c(".", "?"), GFF3 = TRUE)#
			} else {#
				### Read the GFF as a data.table object and then coerce it to a data frame.#
				gff.obj <- data.table::fread(input.gff)#
			}#
		} else {#
			### Creates a path (character string) that the GFF will be saved to #
			temp.name <- tempfile()#
			### Downloads the GFF to temp.name#
			utils::download.file(input.gff,dest=temp.name,quiet=T)#
			### Now check if the downloaded file is a GFF-like table or an actual GFF file (with a GFF header)#
			Line1 <- readLines(temp.name,n=1)#
			if(any(grep("gff-version",Line1))){#
				# Reads the GFF into R as a data.frame object#
				gff.obj   <- ape::read.gff(temp.name, na.strings = c(".", "?"), GFF3 = TRUE)#
				# Removes the temporary file#
				invisible(file.remove(temp.name))#
			} else {#
				gff.obj <- data.table::fread(temp.name)#
			}#
		}#
	} else {#
		if(is(input.gff,"data.frame") | is(input.gff,"matrix")){#
			gff.obj   <- input.gff#
		} else {#
			stop("input.gff has unrecognized format")#
		}#
	}#
	### Coerce to data.table object#
	gff.obj <- data.table::as.data.table(gff.obj)#
	gff.obj#
}
input.gff="/Users/alyssaleinweber/Downloads/Lacerta.agilis_GFF_CDS_longer120bp.txt"
x <- input.gff
filtered.gff1B <- as.data.frame(load.gff(x))
class(filtered.gff1B)
filtered.gff1B <- load.gff(x)
class(filtered.gff1B)
filtered.gff1B
filtered.gff1B <- as.data.frame(load.gff(x))
test <- sapply(filtered.gff1B, mode)
test
numeric.columns <- which(colnames(filtered.gff1B) %in% c("start","end"))
numeric.columns
filtered.gff1B[, numeric.columns] <- sapply(filtered.gff1B[, numeric.columns], as.numeric)
character.columns <- which(!(colnames(filtered.gff1B) %in% c("start","end")))
filtered.gff1B[, character.columns] <- sapply(filtered.gff1B[, character.columns], as.character)
sapply(filtered.gff1B, mode)
refseq.names   <- unlist(filtered.gff1B[,1])
refseq.names[1]
additional.ID
additional.ID<-NULL
!is.null(additional.ID)
subject.id       <- refseq.names
subject.start    <- filtered.gff1B$start
subject.end      <- filtered.gff1B$end
new.names        <- paste0(refseq.names,":",subject.start,"-",subject.end)
new.names[1]
new.names[2]
Lacerta.agilis_exome <- Biostrings::readDNAStringSet(filepath="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Lacerta.agilis_exome_longer120bp.fas")
grep("NC_046312.1:84060818-84061670",names(Lacerta.agilis_exome))
grep("NC_046319.1:36771841-36772193",names(Lacerta.agilis_exome))
57111/length(Lacerta.agilis_exome)
6563/length(Lacerta.agilis_exome)
grep("NC_046312.1:81680187-81681417",names(Lacerta.agilis_exome))
6089/length(Lacerta.agilis_exome)
grep("NC_046313.1:104728512-104728660",names(Lacerta.agilis_exome))
18603/length(Lacerta.agilis_exome)
?data.table()
?fread()
library(REEs)
input.seqs = c("/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Crotalus.horridus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Ophiophagus.hannah.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Pantherophis.guttatus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Thamnophis.sirtalis.tblastx.best.hits_seqs.fas")#
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")#
reference.species = 4#
input.gff = NULL; output.path = NULL, alignments.out=NULL; subgroup=NULL; i.start=1; i.stop=NA; mafft.params="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6"
input.seqs = c("/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Crotalus.horridus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Ophiophagus.hannah.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Pantherophis.guttatus.tblastx.best.hits_seqs.fas","/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Genome_TBLASTXs/Thamnophis.sirtalis.tblastx.best.hits_seqs.fas")#
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")#
reference.species = 4#
input.gff = NULL; output.path = NULL; alignments.out=NULL; subgroup=NULL; i.start=1; i.stop=NA; mafft.params="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6"
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ",".","-"),c("_","_","_"),species)
species
species = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","\.","-"),c("_","_","_"),species)
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","/.","-"),c("_","_","_"),species)
species
species  <- c(species[reference.species],species[-reference.species])#
	species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)
species
species.names = c("Crotalus.horridus","Ophiophagus.hannah","Pantherophis.guttatus","Thamnophis.sirtalis")
species  <- c(species.names[reference.species],species.names[-reference.species])
species
species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)
species
species  <- c(species.names[reference.species],species.names[-reference.species])#
	species  <- mgsub(c(" ","\\.","-"),c("_","_","_"),species)#
	if(is.null(subgroup)){#
		subgroup <- species#
	}#
	if(is.null(output.path)){#
		output.path <- tempfile()#
		delete <- T#
	} else {#
		delete <- F#
	}
species
if(!is.null(alignments.out)){#
		dir.check.create(alignments.out)#
	}
is.subgroup     <- mgrep(query=subgroup,subject=species)
is.subgroup
is(input.seqs[[1]],"character")
input.seqs   <- c(input.seqs[reference.species],input.seqs[-reference.species])
input.seqs
species.seqs <- lapply(X=input.seqs,FUN=function(x){Biostrings::readDNAStringSet(x)})
if(is(input.seqs[[1]],"character")){#
		### Puts the input.seqs in the same order as species.#
		input.seqs   <- c(input.seqs[reference.species],input.seqs[-reference.species])#
		### Read in the sequences for each species as a DNAStringSet, and hold the set of DNAStringSets in a list#
		# Important not to name each DNAStringSet in the list#
		species.seqs <- lapply(X=input.seqs,FUN=function(x){Biostrings::readDNAStringSet(x)})#
	} else { #
		if(is(input.seqs[[1]],"DNAStringSet")){#
			##### Important not to name each DNAStringSet in the list#
			### Puts the input.seqs in the same order as species.#
			input.seqs        <- input.seqs[c(reference.species,c(1:length(input.seqs))[-reference.species])]#
			### Set species.seqs equal to input.seqs in this case.#
			species.seqs <- input.seqs#
		}#
		else {#
			stop("input.seqs must be a list of DNAStringSet objects or a vector of character strings with filepaths to sequences in fasta format")#
		}#
	}
length(species.seqs)
matches.list    <- lapply(X=species.seqs,FUN=function(x){ gsub("_Subject=.*","",names(x))})
length(matches.list)
all.loci        <- unique(unlist(matches.list))
matches.indices.all         <- lapply(X=matches.list,FUN=function(y){match(x=all.loci,table=y)})
species.seqs.all            <- mapply(FUN=function(X,Y){Z=Y[which(!is.na(Y))];X[Z]},X=species.seqs,Y=matches.indices.all,SIMPLIFY=F)
CDS.locus.identifier.all    <- mgsub(c(":","-"),c("_","_"),all.loci)
length(CDS.locus.identifier.all)
CDS.locus.identifier.all[1]
CDS.locus.identifier.all[2]
CDS.locus.identifier.all[3]
loci.ranges.all  <- mgsub(c(".*\\.1:","-"),c("","_"),all.loci)
loci.ranges.all[1]
length(all.loci)
all.loci[1]
mgsub(c(".*\\.1:","-"),c("","_"),all.loci[1])
mgsub(c(".+\\.1:","-"),c("","_"),all.loci[1])
mgsub(c("^.+\\.1:","-"),c("","_"),all.loci[1])
mgsub(c("^.+\\.1.","-"),c("","_"),all.loci[1])
loci.ranges.all  <- mgsub(c(".*\\.1.","-","_Gene=.+"),c("","_",""),all.loci)
loci.ranges.all[1]
loci.lengths.all <- (abs(as.numeric(gsub(".*_","",loci.ranges.all))-as.numeric(gsub("_.*","",loci.ranges.all)))+1)
loci.lengths.all[1]
1014392-1014266
is.null(input.gff)
length(all.loci)
gene.names.all <- rep(NA,length(all.loci))
if(is.na(i.start) | i.start > length(all.loci)){#
		### Default i.start, ie which exons to start the loop at#
		i.start <- 1#
	}#
	if(is.na(i.stop) | i.stop > length(all.loci)){#
		### Default i.stop, ie which exons to stop the loop at#
		i.stop  <- length(all.loci)#
	}
i.start
i.stop
index.matrix.all            <- do.call(rbind, matches.indices.all)
index.matrix.all
if(!is.null(names(species.seqs.all))){#
		names(species.seqs.all) <- NULL#
	}
temp.seqs.all               <- lapply(c(1:ncol(index.matrix.all)),function(input){do.call(c,mapply(FUN=function(A,B){C=B[which(!is.na(B))];A[C]},A=species.seqs.all,B=lapply(X=index.matrix.all[,input],FUN=function(x){x})))})
length(species.seqs.all)
species.seqs.all[[1]]
class(index.matrix.all)
mode(index.matrix.all)
length(index.matrix.all)
index.matrix.all[,1]
test = index.matrix.all[,1]
lapply(X=test, FUN=function(x){x})
as.list(test)
length(species.seqs.all)
which(!is.na(as.list(test)))
as.list(test)[which(!is.na(as.list(test)))]
species.seqs.all[as.list(index.matrix.all[,1])[which(!is.na(as.list(index.matrix.all[,1])))]]
organize.seqs.by.locus <- function(species.seqs,index.matrix){#
	num.loci <- 1:ncol(index.matrix)#
	lapply(X=1:num.loci,FUN=function(i){do.call(c,mapply(FUN=function(A,B){C=B[which(!is.na(B))]; A[C]}, A=species.seqs, B=as.list(index.matrix[,i])))})#
}
test <- organize.seqs.by.locus(species.seqs=species.seqs.all,index.matrix=index.matrix.all)
length(temp.seqs.all)
temp.seqs.all[1]
names.temp.seqs.all         <- apply(X=index.matrix.all,MARGIN=2,FUN=function(input){species[!is.na(input)]})
length(names.temp.seqs.all)
if(is(names.temp.seqs.all,"list")){#
		for(i in 1:length(temp.seqs.all)){#
			names(temp.seqs.all[[i]]) <- names.temp.seqs.all[[i]]#
		}#
	}#
	if(is(names.temp.seqs.all,"matrix")){#
		for(i in 1:length(temp.seqs.all)){#
			names(temp.seqs.all[[i]]) <- names.temp.seqs.all[,i]#
		}#
	}
tempMatrix.all           <- matrix(data=0, nrow=length(1:length(all.loci)), ncol=12+length(species))
tempMatrix.all
colnames(tempMatrix.all) <- c(paste0(species[1],".locus"), "num.Species","CountCover","absolutePIS","percentPIS","mean.pident", paste0("pident.",species), "gene.name",paste0("locus.length.",species[1]),"mean.variable.sites","min.pident.all","min.pident.subgroup","alignment.width")#
	tempMatrix.all[,1]             <- all.loci
nrow(tempMatrix.all)
length(gene.names.all)
gene.names.all[1]
colnames(tempMatrix.all) <- c(paste0(species[1],".locus"), "num.Species","CountCover","absolutePIS","percentPIS","mean.pident", paste0("pident.",species), "gene.name",paste0("locus.length.",species[1]),"mean.variable.sites","min.pident.all","min.pident.subgroup","alignment.width")#
	tempMatrix.all[,1]             <- all.loci#
	tempMatrix.all[,"gene.name"]   <- gsub("gene=","",gene.names.all)#
	tempMatrix.all[,"num.Species"] <- sapply(temp.seqs.all,length)
tempMatrix.all[1:10,]
# Find which column is the gene.name column#
	which.is.gene.name.column <- which(colnames(tempMatrix.all)=="gene.name")#
	# Columns that should be character mode#
	character.columns <- c(1,which.is.gene.name.column)#
	# Columns that should be numeric mode#
	numeric.columns   <- setdiff(1:ncol(tempMatrix.all),character.columns)#
	# Set the mode to numeric for those columns that should be numeric#
	tempMatrix.all[, numeric.columns] <- sapply(tempMatrix.all[, numeric.columns], as.numeric)
tempMatrix.all[1:10,]
class(tempMatrix.all)
tempMatrix.all[,1]             <- all.loci#
	tempMatrix.all[,"gene.name"]   <- gsub("gene=","",gene.names.all)#
	tempMatrix.all[,"num.Species"] <- sapply(temp.seqs.all,length)
tempMatrix   <- tempMatrix.all#
	temp.seqs    <- temp.seqs.all#
	loci.lengths <- loci.lengths.all
i=1
if (as.numeric(tempMatrix[i,"num.Species"])>1){#
			### aligns the ith locus of each species#
#			alignment.temp              <- REEs::mafft(temp.seqs[[i]],param="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6")#
			alignment.temp              <- REEs::mafft(temp.seqs[[i]],param=mafft.params)#
			### Number of sites in alignment#
			alignment.width             <- width(alignment.temp)[1]#
			### pairwise matrix of absolute genetic distance#
			distances                   <- 100*as.matrix(ape::dist.dna(ape::as.DNAbin(alignment.temp),model="raw",pairwise.deletion=T))#
			### Alternative method for calculating genetic distances. Doesnt seem any faster than the ape method.#
			# distances <- (100*(Biostrings::stringDist(alignment.temp)/alignment.width))#
			### pairwise matrix of percent genetic identity#
			pident                      <- round(100-distances,digits=2)#
			mean.pident                 <- round(mean(pident[1,-1]),digits=2)#
			### mean percent identity of the primary species to each of the other species.#
			tempMatrix[i,"mean.pident"] <- mean.pident#
			### percent identity of the primary species to each species in the alignment (including itself, with should be 100% idendical).#
			tempMatrix[i,(7:(length(species)+6))[species %in% names(alignment.temp)]] <- pident[1,]#
			if(any(!species %in% names(alignment.temp))){#
				tempMatrix[i,(7:(length(species)+6))[!species %in% names(alignment.temp)]] <- NA#
			}#
		}
library(REEs)
Aspidoscelis.marmoratus.hits <- "/Users/alyssaleinweber/Downloads/Aspidoscelis.marmoratus.tblastx.exons.hits_max5.hsps5.e15.txt"
input.table=Aspidoscelis.marmoratus.hits; output.table.path=NULL; remove.subseq.matches=T; min.bitscore=50; min.bitscore.difference=0
if(is(input.table,"data.table") | is(input.table,"matrix")){#
		all.matches <- as.data.frame(input.table)#
	}#
	## If input.table is a character string with the filepath, read the file in as a data.table and then coerce it to data frame.#
	if(is(input.table,"character")){#
		all.matches       <- as.data.frame(data.table::fread(input=input.table,sep="\t"))#
	}#
	# Set column names#
	colnames(all.matches) <- c("qseqid","sseqid","pident","length","mismatch","gapopen","qstart","qend","sstart","send","evalue","bitscore")#
	##### Set column modes#
	# Set which columns should be mode numeric#
	numeric.columns <- c(3:12)#
	# Set mode to numeric for those columns that should be numeric#
	all.matches[, numeric.columns] <- sapply(all.matches[, numeric.columns], as.numeric)#
	# Set which columns should be mode character#
	character.columns <- c(1:2)#
	# Set mode to "character" for the columns indexed in the character.columns vector#
	all.matches[, character.columns] <- sapply(all.matches[, character.columns], as.character)#
	### Filter matches with bitscore less than min.bitscore#
	if(any(all.matches$bitscore < min.bitscore)){#
		filtered.matches <- all.matches[-which(all.matches$bitscore < min.bitscore),]#
	} else {#
		filtered.matches <- all.matches#
	}
matches.ordered  <- filtered.matches[with(filtered.matches, order(filtered.matches[,"qseqid"], filtered.matches[,"bitscore"], decreasing=T)),]
remove.subseq.matches
query.subject.pairs <- distinct(matches.ordered[,c("qseqid","sseqid")])
query.subject.pairs <- dplyr::distinct(matches.ordered[,c("qseqid","sseqid")])
query.subject.pairs[1:10,]
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"]) && which which(matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"]) && which(matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"] && matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[2,"qseqid"] && matches.ordered[,"sseqid"] == query.subject.pairs[2,"sseqid"])
query.subject.pairs[2,"qseqid"]
query.subject.pairs[2,"sseqid"]
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"]) & which(matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"])
which(matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"])
matches.ordered[1:4,]
matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[1,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[1,"sseqid"]),]
matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[2,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[2,"sseqid"]),]
matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[3,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[3,"sseqid"]),]
lapply(X=1:10,FUN=function(i){ matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]})
matches.list        <- lapply(X=1:nrow(query.subject.pairs),FUN=function(i){ matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]})
length(matches.list)
nrow(query.subject.pairs)
matches.list <- list(); length(matches.list) <- nrow(query.subject.pairs)
i=1
matches.list[[i]] <- matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]
matches.list[1:10]
for(i in 1:100){#
			matches.list[[i]] <- matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]#
		}
matches.list[1:100]
for(i in 1:nrow(query.subject.pairs)){#
	#	for(i in 1:100){#
			matches.list[[i]] <- matches.ordered[which(matches.ordered[,"qseqid"] == query.subject.pairs[i,"qseqid"] & matches.ordered[,"sseqid"] == query.subject.pairs[i,"sseqid"]),]#
		}
i
matches.list <- matches.list[1:4014]
min.list            <- lapply(matches.list,FUN=function(x){apply(X=x[,c("sstart","send")],MARGIN=1,FUN=min)})#
		max.list            <- lapply(matches.list,FUN=function(x){apply(X=x[,c("sstart","send")],MARGIN=1,FUN=max)})
matches.list[[1]]
apply(X=matches.list[[1]][,c("sstart","send")],MARGIN=1,FUN=min)
apply(X=matches.list[[1]][,c("sstart","send")],MARGIN=1,FUN=max)
matches.list <- matches.list[1:4013]
min.list            <- lapply(matches.list,FUN=function(x){apply(X=x[,c("sstart","send")],MARGIN=1,FUN=min)})
max.list            <- lapply(matches.list,FUN=function(x){apply(X=x[,c("sstart","send")],MARGIN=1,FUN=max)})
subject.ranges      <- IRanges::IRangesList(start=min.list,end=max.list)
drop.hits           <- IRanges::findOverlaps(subject.ranges,drop.self=T,type="within")
remove.rows.list    <- lapply(drop.hits,FUN=function(x){unique(as.matrix(x)[,1])})
dim(remove.rows.list)
length(remove.rows.list)
remove.rows.list[[1]]
remove.rows.list[[2]]
remove.rows.list[[4]]
function1           <- function(A,B){if(length(B)>0){A[-B,]} else{A}}
filtered.matches.ordered.temp  <- t(as.list(mapply(FUN=function1,A=matches.list,B=remove.rows.list)))
filtered.matches.ordered.temp2 <- list(); length(filtered.matches.ordered.temp2) <- ncol(filtered.matches.ordered.temp)
for(i in 1:ncol(filtered.matches.ordered.temp)){#
			filtered.matches.ordered.temp2[[i]] <- unlist(filtered.matches.ordered.temp[,i])#
		}
class(filtered.matches.ordered.temp2)
filtered.matches.ordered           <- as.data.frame(do.call(cbind,filtered.matches.ordered.temp2)
)
dim(filtered.matches.ordered)
filtered.matches.ordered[1:10,]
colnames(filtered.matches.ordered) <- colnames(matches.ordered)
##### Set column modes#
		# Set which columns should be mode numeric#
		numeric.columns <- c(3:12)#
		# Set mode to numeric for those columns that should be numeric#
		filtered.matches.ordered[, numeric.columns] <- sapply(filtered.matches.ordered[, numeric.columns], as.numeric)#
		# Set which columns should be mode character#
		character.columns <- c(1:2)#
		# Set mode to "character" for the columns indexed in the character.columns vector#
		filtered.matches.ordered[, character.columns] <- sapply(filtered.matches.ordered[, character.columns], as.character)
filtered.matches.ordered[1:10,]
best.matches          <- as.numeric(match(unique(filtered.matches.ordered$qseqid), filtered.matches.ordered$qseqid))
best.matches[1]
best.data             <- filtered.matches.ordered[best.matches,]
best.data[1:10,]
if(min.bitscore.difference!=0){#
		without.best.data     <- filtered.matches.ordered[-best.matches,]#
		second.best.matches   <- as.numeric(match(unique(filtered.matches.ordered$qseqid), without.best.data$qseqid))#
		second.best.data      <- without.best.data[second.best.matches]#
		#### If a query does not have a second best match, then a bitscore of zero is used for an dummy second match. There is no consequence for having a single strong match.#
		if(any(is.na(second.best.matches))){#
			second.best.data$bitscore[which(is.na(second.best.matches))] <- 0#
		}#
		bitscore.difference             <- as.numeric(best.data$bitscore)-as.numeric(second.best.data$bitscore)#
		if(any(bitscore.difference < min.bitscore.difference)){#
			best.data <- best.data[-which(bitscore.difference < min.bitscore.difference)]#
		}#
	}
best.data[1:10,]
result <- data.table::as.data.table(best.data)
result
.libPaths("/Users/alyssaleinweber/Documents/test_install")
.libPaths
.libPaths()
install.packages(pkgs="BiocManager",repos = "http://cran.us.r-project.org")
find.package("BiocManager")
library(BiocManager)
search()
library(REEs)
Lacerta.agilis_exome <- Biostrings::readDNAStringSet(filepath="/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/Lacerta.agilis_exome_longer120bp.fas")
grep("NC_046313.1:109543642-109543827",names(Lacerta.agilis_exome))
library(devtools)
setwd("Documents/REEs")
devtools::document()
bait.number=1000
bait.number=1000; bait.length=120; bait.tiling=0.5
!is.null(bait.number)
!is.null(bait.number) & (is.null(bait.length) | is.null(bait.tiling))
bait.number=1000; bait.length=120; bait.tiling=NULL
!is.null(bait.number) & (is.null(bait.length) | is.null(bait.tiling))
bait.number=1000; bait.length=NULL; bait.tiling=0.5
!is.null(bait.number) & (is.null(bait.length) | is.null(bait.tiling))
bait.number=1000; bait.length=NULL; bait.tiling=NULL
!is.null(bait.number) & (is.null(bait.length) | is.null(bait.tiling))
bait.number=NULL; bait.length=NULL; bait.tiling=NULL
!is.null(bait.number) & (is.null(bait.length) | is.null(bait.tiling))
bait.number=NULL; bait.length=120; bait.tiling=0.5
!is.null(bait.number) & (is.null(bait.length) | is.null(bait.tiling))
library(REEs)
stats.table4 <- data.table::fread("/Users/alyssaleinweber/Documents/SequenceCapture-GitHub/statsTable_REEs_SnakeCap.txt")
nrow(stats.table4)
stats.table4 <- as.data.frame(stats.table4)
length(which(colnames(stats.table4)==paste0("locus.length.",mgsub(c(" ","-"),c("_","_"),primary.species))))==0
length(which(colnames(stats.table4)==paste0("locus.length.",mgsub(c(" ","-"),c("_","_"),"Thamnophis.sirtalis"))))==0
colnames(stats.table4)
length(which(colnames(stats.table4)==paste0("locus.length.",mgsub(c(" ","-","."),c("_","_","_"),"Thamnophis.sirtalis"))))==0
mgsub(c(" ","-","."),c("_","_","_"),"Thamnophis.sirtalis")
length(which(colnames(stats.table4)==paste0("locus.length.",mgsub(c(" ","-","\\."),c("_","_","_"),"Thamnophis.sirtalis"))))==0
mgsub(c(" ","-","\\."),c("_","_","_"),"Thamnophis.sirtalis")
grep("^locus.length.",colnames(stats.table4))
length(grep("^locus.length.",colnames(stats.table4)))
find.packages("REEs")
find.package("REEs")
