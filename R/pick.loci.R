#' Pick Rapidly-evolving Exons
#' 
#' This function picks rapidly evolving exons (REEs) to target for sequence capture, given an input table of sequence alignment statistics that was generated using the function makeExomeStatsTable.
#'
#' @param statsTable.path Path to the input stats table, which is the table generated by the function makeExomeStatsTable. Example: "stats_exome_data_TBLASTX.txt".
#' @param primary.species The species whose contigs are in the first column of the input table indicated by the statsTable.path argument. For each locus, the other species were aligned to this species when the function makeStatsTable was run.
#' @param output.path Path where output table should be saved. If NULL (the default), then the output is not written to a file. If the output file already exists a warning message will be generated and the function will terminate.
#' @param species.subgroup This is a character vector of species names and should have the same value as what was used for the "subgroup" argument when the function makeStatsTable was run.
#' @param pident.keep Minimum and maximum values for min.pident necessary to keep locus.
#' @param max.loci.per.gene Maximum number of rapidly-evolving exons (REEs) to target from the same gene. Default is NULL, which means max REEs/gene is unlimited. If set to number, n, then at most only the n fastest-evolving REEs per gene can be included in the output.
#' @param min.num.species Either a number that indicates the minimum number of species with the locus, or else the locus is filtered, or the character string "all" (the default), which means that the locus must be present in all of the species.
#' @param max.capture.coverage Maximum number of nucleotides that can be targeted. Default is 1200000.
#' @param plot.results Whether or not results should be plotted. Need to check on what this plot looks like...
#' @param use.min.pident.subgroup Whether or not the minimum of the pident.keep argument should be compared to the minimum of pident among the subgroup set of species defined by the species.subgroup argument. Default is FALSE, such that minimum pident.keep is compared to the minimum pident among all species in the input stats table.
#' @param fast.stat Character string (or character vector of length 1) indicating which statistic should be used as the metric for "rate of evolution" of loci. The options are:
#' (1) "pident" (the default) is the mean percent of sites identical to the primary species (which is defined by the primary.species argument); pident is assumed to decrease as evolutionary rate increases.
#' (2) "percentPIS" is the mean percent of sites that are parsimony informative AND not identical to the primary species; percentPIS is assumed to increase as evolutionary evolutionary rate increases.
#' @return A list holding the input stats table, the input stats table after sorting by fast.stat, and the two stats tables that are also written to files (if write.stats.tables = TRUE). The names of these tables is also included in the output list.
#' @export pick.loci
pick.loci <- function(statsTable.path, primary.species, output.path=NULL, species.subgroup=NULL, pident.keep=c(65,100),max.loci.per.gene=NULL, min.num.species="all",max.capture.coverage=1200000, plot.results=FALSE,use.min.pident.subgroup=FALSE,fast.stat="pident"){
	#stats.data.exome         <- data.table::fread(input=statsTable.path,sep="\t",header=T)                     ### Reads in the full stats table generated by makeStatsTable function
	#stats.data.exome          <- data.table::fread(input=statsTable.path,header=T)                             ### Reads in the full stats table generated by makeStatsTable function
	
	if(class(statsTable.path) %in% "data.frame"){
		stats.table0 <- data.table::data.table(statsTable.path)
	}
	if(class(statsTable.path) %in% "character"){
		### Read in the data table produced by the function makeStatsTable
		stats.table0               <- data.table::fread(input=statsTable.path,header=T)
		# Update the gene.name column so that character string "gene=" is not included before the gene name. Eventually you wont need this next line.
		stats.table0$gene.name     <- gsub("gene=","",stats.table0$gene.name)
	}
	
	################
	### Filter rows loci if too few species sampled.
	# Set min.num.species to the total number of species if default value of "all" was used.
	if(min.num.species=="all"){
		#min.num.species <- (ncol(stats.table0)-12)
		min.num.species <- length(grep("^pident.",colnames(stats.table0)))
	}
	to.keep0 <- which(as.numeric(stats.table0$num.Species) >= min.num.species)
	if(length(to.keep0)>0){
		stats.table0          <- stats.table0[to.keep0,]
	} else {
		stop("No loci with num.Species >= min.num.species")
	}

	################
	### Order the data table by decreasing speed of evolution (as measured by the value of the fast.stat parameter).
	# Set min.num.species to the total number of species if default value of "all" was used.
	if(fast.stat == "pident"){
		#mean.pident.fast             <- stats.data.FastestExonPerGene$mean.pident                                              ###| Orders exon stats table by increasing mean percent identity to T. sirtalis
#		stats.data.exome.ordered      <- stats.data.exome[with(stats.data.exome, order(gene.name, mean.pident, decreasing=F)),] ### Sorts loci by gene name, and then by increasing percent identity to the primary species.
		stats.table1      <- stats.table0[with(stats.table0, order(gene.name, mean.pident, decreasing=F)),] ### Sorts loci by gene name, and then by increasing percent identity to the primary species.
	}
	if(fast.stat == "percentPIS"){
		#mean.percentPIS               <- stats.data.FastestExonPerGene$percentPIS                              ###| Orders exon stats table by increasing percent of sites parsimonious
#		stats.data.exome.ordered      <- stats.data.exome[with(stats.data.exome, order(gene.name, percentPIS, decreasing=T)),] ### Sorts loci by gene name, and then by decreasing percent of sites parsimony informative.
		stats.table1      <- stats.table0[with(stats.table0, order(gene.name, percentPIS, decreasing=T)),] ### Sorts loci by gene name, and then by decreasing percent of sites parsimony informative.
	}
	if(nrow(stats.table1)==0){
		stop("No REEs identified because all loci filtered.")
	}

	### Adding the min.pident.all and min.pident.subgroup columns if they dont already exist. Input stats tables generated with the latest version of makeStatsTable should already have these columns.
	if(!all((c("min.pident.all","min.pident.subgroup") %in% colnames(stats.table1)))){
		### Make a data frame copy of the data table, because it's easier to subset a data frame by columns compared to a data table.
		stats.df1      <- as.data.frame(stats.table1)
		### Adding the min.pident.all column if it doesnt already exist
		if(!("min.pident.all" %in% colnames(stats.table1))){
			### Specifies which columns to evaluate min.pident across. Need to make sure than NA values are treated correctly.
			# all.pident.columns      <- grep("pident.",colnames(stats.data.exome))[which(grep("pident.",colnames(stats.data.exome)) < grep("gene.name",colnames(stats.data.exome)))][-1]
			# min.pident.all          <- round(apply(X=stats.data.exome.ordered[,..all.pident.columns],MARGIN=1,FUN=min),digits=2) #| [NOTE: Must have the ".." before the object "all.pident.columns" to specify that it is an integer index.] This line Calculates minimum percent identity (among all species to primary species)
			# Must have the ".." before the object "all.pident.columns" to specify that it is an integer index.] This line Calculates minimum percent identity (among all species to primary species)
			#pident.df      <- as.data.frame(stats.df1[,as.numeric(grep("pident.",colnames(stats.table0))[which(grep("pident.",colnames(stats.table0)) < grep("gene.name",colnames(stats.table0)))][-1])])
			min.pident.all <- round(apply(X=stats.df1[,as.numeric(grep("pident.",colnames(stats.table0))[which(grep("pident.",colnames(stats.table0)) < grep("gene.name",colnames(stats.table0)))][-1])],MARGIN=1,FUN=min),digits=2)
			# Adds the minimum percent identity (all species) stat as a column if it doesnt already exist
			stats.table1   <- cbind(stats.table1,min.pident.all)
		}
		### Adding the min.pident.subgroup column if it doesnt already exist AND if species.subgroup is not set to NULL
		# Dealing with the subgroup
		if(!("min.pident.subgroup" %in% colnames(stats.table1)) & !is.null(species.subgroup)){
				if(is.integer(species.subgroup)){
					#subgroup.pident.columns  <- species.subgroup
					# Calculates minimum percent identity (among subgroup species to primary species)
					min.pident.subgroup      <- round(apply(X=stats.table1[,..species.subgroup],MARGIN=1,FUN=min),digits=2)
				}
				if(is.character(species.subgroup)){
					expected.colnames       <- paste0("pident.",mgsub(c("\\."," "),c("_","_"),species.subgroup))
					#subgroup.pident.columns <- match(expected.colnames,colnames(stats.table0))
					# Calculates minimum percent identity (among subgroup species to primary species)
					min.pident.subgroup      <- round(apply(X=stats.df1[,match(expected.colnames,colnames(stats.table0))],MARGIN=1,FUN=min),digits=2)
				}
				# Adds the minimum percent identity (subgroup species) stat as a column if it doesnt already exist
				stats.table1 <- cbind(stats.table1,min.pident.subgroup)
		}
	}
	### Sets which min.pident value to use when filtering rows that are too distantly related.
	if(use.min.pident.subgroup==T){
		min.pident.filter <- stats.table1$min.pident.subgroup
	} else {
		min.pident.filter <- stats.table1$min.pident.all
	}

	#############
	#### Filter loci if minimum percent identity to primary.species is < pident.keep[1] or >= pident.keep[2] (usually 65% and 100%, respectively)
	to.keep1       <- which(min.pident.filter >= pident.keep[1] & min.pident.filter < pident.keep[2])
	stats.table2   <- stats.table1[to.keep1,]
	
	if(nrow(stats.table2)==0){
		stop("No REEs identified because all loci filtered.")
	}

	############
	#### Filter loci except for the n fastest-evolving loci per gene (where n = value of max.loci.per.gene parameter; if NULL, no loci are filtered; For SnakeCap I used max.loci.per.gene = 1).
	if(is.null(max.loci.per.gene)){
		stats.table3 <- stats.table2
	} else {
		#if(max.loci.per.gene==1){
#			to.keep2     <- match(unique(stats.table2$gene.name),stats.table2$gene.name)
#			stats.table3 <- stats.table2[to.keep2,]
			to.keep2     <- nmatch(unique(stats.table2$gene.name),stats.table2$gene.name,n=max.loci.per.gene)
			stats.table3 <- stats.table2[to.keep2,]
		#} else {
		#	for(i in 1:max.loci.per.gene){
		#		if(i==1){
		#			to.keep2.temp        <- match(unique(stats.table2$gene.name),stats.table2$gene.name)
		#			stats.table3.temp    <- stats.table2[to.keep2.temp,]
		#			remainder.table.temp <- stats.table2[-to.keep2.temp,]
		#		} else {
		#			to.keep2.temp        <- match(unique(remainder.table.temp$gene.name),remainder.table.temp$gene.name)
		#			stats.table3.temp    <- cbind(stats.table3.temp,remainder.table.temp[to.keep2.temp,])
		#			remainder.table.temp <- remainder.table.temp[-to.keep2.temp,]
		#		}
		#	}
		#}
	}
	# Creates a table containing only the n fastest-evolving CDS per gene
	# stats.data.FastestExonPerGene <- stats.table2[to.keep2,]
	
	
	if(nrow(stats.table3)==0){
		stop("No REEs identified because all loci filtered.")
	}
	
	############
	#if(write.stats.tables == T){
	#	if(!file.exists(paste0(output.dir,"stats_data_FastestExonPerGene.txt"))){
	#			write.table(stats.data.FastestExonPerGene,file=paste0(output.dir,"stats_data_FastestExonPerGene.txt"),sep="\t",col.names=T,row.names=F,append=F)
	#	} else {
	#		stop(paste0("The output file ",output.dir,"stats_data_FastestExonPerGene.txt"," already exists."))
	#	}
	#}

	# Orders rows of stats table by increasing mean percent identity to the primary species
	if(fast.stat == "pident"){
		#mean.pident.fast                      <- stats.data.FastestExonPerGene$mean.pident
		#stats.data.FastestExonPerGene.ordered <- stats.data.FastestExonPerGene[with(stats.data.FastestExonPerGene,order(mean.pident,decreasing=F)),]
		stats.table4  <- stats.table3[with(stats.table3,order(mean.pident,decreasing=F)),]
	}
	
	# Orders rows of stats table by decreasing percent of sites parsimony informative
	if(fast.stat == "percentPIS"){
		#mean.percentPIS                       <- stats.data.FastestExonPerGene$percentPIS
		#stats.data.FastestExonPerGene.ordered <- stats.data.FastestExonPerGene[with(stats.data.FastestExonPerGene,order(mean.percentPIS,decreasing=T)),]
		stats.table4 <- stats.table3[with(stats.table3,order(mean.percentPIS,decreasing=T)),]
	}
	
	###### Creates a column holding exon lengths for the primary species, if such a column doesnt already exist.
	if(length(which(colnames(stats.table4)==paste0("locus.length.",mgsub(c(" ","-"),c("_","_"),primary.species))))==0){
		loci.ranges  <- gsub(".*\\.1_","",stats.table4[,1])
		loci.lengths <- (abs(as.numeric(gsub(".*_","",loci.ranges))-as.numeric(gsub("_.*","",loci.ranges)))+1)
		stats.table4 <- cbind(stats.table4,loci.lengths)
		colnames(stats.table4)[which(colnames(stats.table4)=="loci.lengths")] <- paste0("locus.length.",mgsub(c(" ","-"),c("_","_"),primary.species))
	}
	
	###### Calculate the rolling sum of the loci lengths column. Then, remove rows with rolling sum > max.capture.coverage
	loci.lengths.column                <- which(colnames(stats.table4)==paste0("locus.length.",mgsub(c(" ","-"),c("_","_"),primary.species)))
	roll.sum                           <- rollSum(unlist(stats.table4[,loci.lengths.column,with=F]))
	#stats.data.FastestExonPerGene.best <- stats.table4[which(roll.sum <= max.capture.coverage),]
	stats.table5 <- stats.table4[which(roll.sum <= max.capture.coverage),]

	if(!is.null(output.path)){
		#if(!file.exists(paste0(output.dir,"stats_data_FastestExonPerGene.txt"))){
		#		write.table(stats.table2,file=paste0(output.dir,"stats_data_FastestExonPerGene.txt"),sep="\t",col.names=T,row.names=F,append=F)
		#} else {
		#	stop(paste0("The output file ",output.dir,"stats_data_FastestExonPerGene.txt"," already exists."))
		#}
		#if(!file.exists(paste0(output.dir,"stats_data_FastestExonPerGene_best.txt"))){
		#	write.table(stats.table5,file=paste0(output.dir,"stats_data_FastestExonPerGene_best.txt"),sep="\t",col.names=T,row.names=F,append=F)
		#} else {
		#	stop(paste0("The output file ",output.dir,"stats_data_FastestExonPerGene_best.txt"," already exists."))
		#}
		if(!file.exists(output.path)){
			write.table(stats.table5,file=output.path,sep="\t",col.names=T,row.names=F,append=F)
		} else {
			stop(paste0("The output file ",output.path," already exists."))
		}
	}
	
	#mean.pident.dens               <- density(stats.data.exome$mean.pident)                    ###| Density data to be plotted later
	#mean.pident.dens.keep1         <- density(stats.data.exome.ordered$mean.pident)            ###| After filtering to keep only loci within the range of pident.keep
	#mean.pident.dens.keep2         <- density(stats.data.FastestExonPerGene$mean.pident)       ###| After filtering to keep only fastest exon per gene
	#mean.pident.dens.best          <- density(stats.data.FastestExonPerGene.best$mean.pident)  ###| After filtering to keep only the fastest exons with concatenated length < max.capture.coverage
		
	if (plot.results==T){
		mean.pident.hist               <- hist(stats.table0$mean.pident,breaks=round(max(stats.table0$mean.pident)-min(stats.table0$mean.pident)),plot=F)                                                        ###| Histogram data to be plotted later
		mean.pident.hist.keep1         <- hist(stats.table1$mean.pident,breaks=round(max(stats.table1$mean.pident)-min(stats.table1$mean.pident)),plot=F)                                ###| After filtering to keep only loci within the range of pident.keep
		mean.pident.hist.keep2         <- hist(stats.table3$mean.pident,breaks=round(max(stats.table3$mean.pident)-min(stats.table3$mean.pident)),plot=F)                 ###| After filtering to keep only fastest exon per gene
		mean.pident.hist.best          <- hist(stats.table5$mean.pident,breaks=round(max(stats.table5$mean.pident)-min(stats.table5$mean.pident)),plot=F)  ###| After filtering to keep only the fastest exons with concatenated length < max.capture.coverage
		
		par(mfrow=c(4,1), mar=c(1,1,1,1),oma=c(4,4,0,0))  ### 4 rows and 1 column of plots
		cexSize   <- 1              # text size
		x.lab2   <- "% identical"   # xlabel 2
		y.lab2   <- "# loci"        # y label 2
		x.lab    <- NULL            #| x label, y label, and plot title
		y.lab    <- NULL            #|
		main.lab <- NULL            #|
		
		x.lim.min <- mround(x=min(stats.table0$mean.pident),base=5,direction="down")  ### Determines the mininum x-axis value
		
		plot(mean.pident.hist, xlim=c(x.lim.min,100), xlab=NULL, ylab=y.lab2, main = main.lab,cex.main=cexSize,col="grey")  ### Histogram
		Axis(side=2)
		text(x=c(((par("usr")[2]-par("usr")[1])/10)+par("usr")[1]),y= c(((par("usr")[4]-par("usr")[3])/2)+par("usr")[3]),labels=c("Exon Set 1 (all annotated exons)"),cex=1,col=1,adj=c(0,NA))
		lines(x=rep(mean(stats.table0$mean.pident),2),y=c(0,par("usr")[4]),col="green")
		
		plot(mean.pident.hist.keep1, xlim=c(x.lim.min,100), xlab=NULL, ylab=y.lab2, main = main.lab,cex.main=cexSize,col="grey")
		Axis(side=2)
		text(x=c(((par("usr")[2]-par("usr")[1])/10)+par("usr")[1]),y= c(((par("usr")[4]-par("usr")[3])/2)+par("usr")[3]),labels= c("Exon Set 2: subset of Exon Set 1 in which:"),cex=1,col=1,adj=c(0,NA))
		text(x=c(((par("usr")[2]-par("usr")[1])/10)+par("usr")[1]),y= c(((par("usr")[4]-par("usr")[3])/2.5)+par("usr")[3]),labels= paste("100% > minimum similarity to ",gsub("_"," ",primary.species)," ≥ ",pident.keep[1],"%",sep=""),cex=1,col=1,adj=c(0,NA))
		lines(x=rep(mean(stats.table1$mean.pident),2),y=c(0,par("usr")[4]),col="green")
		
		plot(mean.pident.hist.keep2, xlim=c(x.lim.min,100), xlab=NULL, ylab=y.lab2, main = main.lab,cex.main=cexSize,col="grey")
		Axis(side=2)
		text(x=c(((par("usr")[2]-par("usr")[1])/10)+par("usr")[1]),y= c(((par("usr")[4]-par("usr")[3])/2)+par("usr")[3]),labels=c("Exon Set 3: fastest exon/gene of Exon Set 2"),cex=1,col=1,adj=c(0,NA))
		lines(x=rep(mean(stats.table3$mean.pident),2),y=c(0,par("usr")[4]),col="green")
		
		plot(mean.pident.hist.best, xlim=c(x.lim.min,100), xlab=NULL, ylab=y.lab2, main = main.lab,cex.main=cexSize,col="grey")
		Axis(side=2)
		text(x=c(((par("usr")[2]-par("usr")[1])/10)+par("usr")[1]),y= c(((par("usr")[4]-par("usr")[3])/2)+par("usr")[3]),labels= c("Exon Set 4: fastest exons of Exon Set 3 in which:"),cex=1,col=1,adj=c(0,NA))
		text(x=c(((par("usr")[2]-par("usr")[1])/10)+par("usr")[1]),y= c(((par("usr")[4]-par("usr")[3])/2.5)+par("usr")[3]),labels= paste("sum(exon lengths) < ",max.capture.coverage,"nt",sep=""),cex=1,col=1,adj=c(0,NA))
		lines(x=rep(mean(stats.table5$mean.pident),2),y=c(0,par("usr")[4]),col="green")
		
		mtext(paste("% of sites identical to ", gsub("_"," ",primary.species)),c(SOUTH=1),line=2, cex=1, outer=TRUE)
		mtext(c("number of exons"),c(WEST=2),line=1.5, cex=1, outer=TRUE)
	}
	
	result        <- list(stats.table0,stats.table1,stats.table3,stats.table4,stats.table5)
	# Notes:
	# result[[1]] = Table 1 = Table of unique CDS regions above min length. Row order is the same as in the input table.
	# result[[2]] = Table 2 = Subset of Table 1 with pident above cuttoff (if fast.stat = "pident") or percentPIS below cutoff (if fast.stat = "percentPIS"). Rows are sorted by gene name and then by value of fast.stat
	# result[[3]] = Table 3 = Subset of Table 2 with only fastest n exons per gene.
	# result[[4]] = Table 4 = Same loci as Table 3, but rows are sorted by value of fast.stat.
	# result[[5]] = Table 5 = Subset of Table 4 with rolling sum of loci lengths is less than the value of max.capture.coverage

	result.return <- result[[5]]
	result.return
}
#' @examples
#' 
#' ### Load GFF table from NCBI repository.
#' Thamnophis.sirtalis_GFF.url <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/001/077/635/GCF_001077635.1_Thamnophis_sirtalis-6.0/GCF_001077635.1_Thamnophis_sirtalis-6.0_genomic.gff.gz"
#' Thamnophis.sirtalis_GFF     <- load.gff(input=Thamnophis.sirtalis_GFF.url,local=F)
#' 
#' # Filter Thamnophis.sirtalis_GFF to only include CDS features with length at least 120bp
#' Thamnophis.sirtalis_GFF_CDS_longer120bp <- filter.gff(input.gff=Thamnophis.sirtalis_GFF,feature.type="CDS",min.length=120)
#' 
#' ### Use get.exome.from.annotationTable to extract the sequences for the loci in the filtered GFF
#' Thamnophis.sirtalis_genome.path <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCF/001/077/635/GCF_001077635.1_Thamnophis_sirtalis-6.0/GCF_001077635.1_Thamnophis_sirtalis-6.0_genomic.fna.gz"
#' Thamnophis.sirtalis_exome <- get.seqs.from.gff(input.seqs=Thamnophis.sirtalis_genome.path,input.gff=Thamnophis.sirtalis_GFF_CDS_longer120bp)
#' 
#' ### Use tblastx to return up to 50 matches for each of query sequence in a subject sequence database
#' # Define the query sequences. In this example, query sequences are the first sequences in the Thamnophis sirtalis exome DNAStringSet object.
#' test.query    <- Thamnophis.sirtalis_exome[1:2]
##'### Or read from fasta file
#' test.query    <- readDNAStringSet("/Users/alyssaleinweber/Documents/REES_test_output/Thamnophis.sirtalis_twoExons_testQuery.fas")
#' 
#' # Define which sequences to blast against (subject sequences). In this case, the we provide the URL path to the Crotalus horridus genome (the subject sequences).
#' Crotalus.horridus.genome_url  <- "https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/001/625/485/GCA_001625485.1_ASM162548v1/GCA_001625485.1_ASM162548v1_genomic.fna.gz"
#'
#' # URLs to other example genomes (including the Crotalus.horridus.genome_url just defined) are included in this package and can be accessed with the datasets() function:
#' datasets(1) ### Prints a list of URLs to whole genomes of 11 snake species and 3 lizard species.
#' 
#' Anolis.carolinensis.genome_url           <- datasets(1)[2,2]
#' Gekko.japonicus.genome_url               <- datasets(1)[3,2]
#' Pagona.vitticeps.genome_url              <- datasets(1)[4,2]
#' Crotalus.mitchellii.genome_url           <- datasets(1)[6,2]
#' Ophiophagus.hannah.genome_url            <- datasets(1)[7,2]
#' Pantherophis.guttatus.genome_url         <- datasets(1)[8,2]
#' Protobothrops.mucrosquamatus.genome_url  <- datasets(1)[9,2]
#' Python.bivittatus.genome_url             <- datasets(1)[10,2]
#' Viperus.berus.genome_url                 <- datasets(1)[11,2]
#'
#' # Running the blast function.
#' Anolis.carolinensis.50hits          <- blast(method="tblastx",subject=Anolis.carolinensis.genome_url,query=test.query)
#' Gekko.japonicus.50hits              <- blast(method="tblastx",subject=Gekko.japonicus.genome_url,query=test.query,table.out="/Users/alyssaleinweber/Documents/REES_test_output/Gekko.japonicus_TwoExons.testQuery.tblastx.50hits.txt")
#' Pagona.vitticeps.50hits             <- blast(method="tblastx",subject=Pagona.vitticeps.genome_url,query=test.query,table.out="/Users/alyssaleinweber/Documents/REES_test_output/Pagona.vitticeps_TwoExons.testQuery.tblastx.50hits.txt")
#' Crotalus.horridus.50hits            <- blast(method="tblastx",subject=Crotalus.horridus.genome_url,query=test.query)
#' Crotalus.mitchellii.50hits          <- blast(method="tblastx",subject=Crotalus.mitchellii.genome_url,query=test.query)
#' Ophiophagus.hannah.50hits           <- blast(method="tblastx",subject=Ophiophagus.hannah.genome_url,query=test.query)
#' Pantherophis.guttatus.50hits        <- blast(method="tblastx",subject=Pantherophis.guttatus.genome_url,query=test.query)
#' Protobothrops.mucrosquamatus.50hits <- blast(method="tblastx",subject=Protobothrops.mucrosquamatus.genome_url,query=test.query)
#' Python.bivittatus.50hits            <- blast(method="tblastx",subject=Python.bivittatus.genome_url,query=test.query)
#' Viperus.berus.50hits                <- blast(method="tblastx",subject=Viperus.berus.genome_url,query=test.query)
#' 
#' ### Filter results to include only the best match for each query sequence
#' best.hits.Anolis.carolinensis           <- reportBestMatches(Anolis.carolinensis.50hits)
#' best.hits.Gekko.japonicus               <- reportBestMatches(Gekko.japonicus.50hits,output.table.path="/Users/alyssaleinweber/Documents/REES_test_output/Gekko.japonicus_TwoExons.testQuery.tblastx.best.hits.txt")
#' best.hits.Pagona.vitticeps              <- reportBestMatches(Pagona.vitticeps.50hits,output.table.path="/Users/alyssaleinweber/Documents/REES_test_output/Pagona.vitticeps_TwoExons.testQuery.tblastx.best.hits.txt")
#' best.hits.Crotalus.horridus             <- reportBestMatches(Crotalus.horridus.50hits)
#' best.hits.Crotalus.mitchellii           <- reportBestMatches(Crotalus.mitchellii.50hits)
#' best.hits.Ophiophagus.hannah            <- reportBestMatches(Ophiophagus.hannah.50hits)
#' best.hits.Pantherophis.guttatus         <- reportBestMatches(Pantherophis.guttatus.50hits)
#' best.hits.Protobothrops.mucrosquamatus  <- reportBestMatches(Protobothrops.mucrosquamatus.50hits)
#' best.hits.Python.bivittatus             <- reportBestMatches(Python.bivittatus.50hits)
#' best.hits.Viperus.berus                 <- reportBestMatches(Viperus.berus.50hits)
#' 
#' ### Extract the subject sequences for the best matches
#' Crotalus.horridus.best.hits.seqs <- get.seqs.from.blastTable(input.blastTable=best.hits.Crotalus.horridus,input.seqs=Crotalus.horridus.genome_url,output.path="/Users/alyssaleinweber/Documents/REES_test_output/Crotalus.horridus_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' ### Same as next lines:
#' Anolis.carolinensis.best.hits.seqs          <- get.seqs.from.blastTable(input.blastTable=best.hits.Anolis.carolinensis,input.seqs=Anolis.carolinensis.genome_url,output.path="/Users/alyssaleinweber/Documents/REES_test_output/Anolis.carolinensis_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Gekko.japonicus.best.hits.seqs              <- get.seqs.from.blastTable(input.blastTable=best.hits.Gekko.japonicus,input.seqs=Gekko.japonicus.genome_url,output.path="/Users/alyssaleinweber/Documents/REES_test_output/Gekko.japonicus_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Pagona.vitticeps.best.hits.seqs             <- get.seqs.from.blastTable(input.blastTable=best.hits.Pagona.vitticeps,input.seqs=Pagona.vitticeps.genome_url,output.path="/Users/alyssaleinweber/Documents/REES_test_output/Pagona.vitticeps_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Crotalus.horridus.best.hits.seqs            <- get.seqs.from.blastTable(input.blastTable=best.hits.Crotalus.horridus,input.seqs="/Users/alyssaleinweber/Documents/genomes/genomes_seqs/GCA_001625485.1_ASM162548v1_genomic.fna.gz",output.path="./Crotalus.horridus_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Crotalus.mitchellii.best.hits.seqs          <- get.seqs.from.blastTable(input.blastTable=best.hits.Crotalus.mitchellii,input.seqs="/Users/alyssaleinweber/Documents/genomes/genomes_seqs/GCA_000737285.1_CrotMitch1.0_genomic.fna.gz",output.path="./Crotalus.mitchellii_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Ophiophagus.hannah.best.hits.seqs           <- get.seqs.from.blastTable(input.blastTable=best.hits.Ophiophagus.hannah,input.seqs="https://ftp.ncbi.nlm.nih.gov/genomes/all/GCA/000/516/915/GCA_000516915.1_OphHan1.0/GCA_000516915.1_OphHan1.0_genomic.fna.gz",output.path="./Ophiophagus.hannah_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Pantherophis.guttatus.best.hits.seqs        <- get.seqs.from.blastTable(input.blastTable=best.hits.Pantherophis.guttatus,input.seqs=Pantherophis.guttatus.genome_url,output.path="./Pantherophis.guttatus_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Protobothrops.mucrosquamatus.best.hits.seqs <- get.seqs.from.blastTable(input.blastTable=best.hits.Protobothrops.mucrosquamatus,input.seqs=Protobothrops.mucrosquamatus_genome.url,output.path="/Users/alyssaleinweber/Documents/REES_test_output/Protobothrops.mucrosquamatus_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Python.bivittatus.best.hits.seqs            <- get.seqs.from.blastTable(input.blastTable=best.hits.Python.bivittatus,input.seqs=Python.bivittatus.genome_url,output.path="/Users/alyssaleinweber/Documents/REES_test_output/Python.bivittatus_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' Viperus.berus.best.hits.seqs                <- get.seqs.from.blastTable(input.blastTable=best.hits.Viperus.berus,input.seqs=Viperus.berus.genome_url,output.path="/Users/alyssaleinweber/Documents/REES_test_output/Viperus.berus_TwoExons.testQuery.tblastx.best.hits_seqs.fas")
#' 
#' ### Align homologous sequences and make a stats table to summarizing variation in each alignment (one row per aligned locus).
#' input.seqs.paths <- .... ### paths to the "best.hits.seqs" files
#' alignments.dir   <-      ### where to save the output alignments
#' table.out        <-      ### where to save the output table
#' species.temp     <-      ### vector of species names associated with the input.seqs.paths
#' stats.table      <- makeStatsTable(input.seqs=input.seqs.paths,species=species.temp,input.gff=Thamnophis.sirtalis_GFF_CDS_longer120bp,output.path=table.out,alignments.out=alignments.dir,species.gff=10)


#' Need to provide the input file. How do I call this data?
#' statsTable.path <- "/Users/alyssaleinweber/Documents/REES_test_output/statsTable_twoExons_test2.txt" ### This is a test table this only the first two exons
#' output.dir      <- "/Users/alyssaleinweber/Documents/REES_test_output/picked-loci-table_test.txt"
#' result.pident   <- pick.loci(statsTable.path = "~/AlignedExonStats/stats_exome_data_TBLASTX.txt", output.dir = "~/AlignedExonStats/", primary.species = "Thamnophis_sirtalis", use.min.pident.subgroup = T, species.subgroup = c(7:14), min.pident.keep = c(65,100), max.capture.coverage = 1200000, write.stats.tables = T, plot.results = T, fast.stat = "pident")











