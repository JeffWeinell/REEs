#' Step 3b: target matching assessment
#'
#' This function performs step 3b of the post-sequencing pipeline used for SnakeCap
#' In this step, haplocontig consensus sequences generating during step 2 (dipspades.sh), target sequences used to generate probes prior to sequencing, and blast hit tables generated during step 3a (targetMatching.sh) are processed to sort/filer assembled consensus haplocontigs
#' 
#' @param workdir Path to the directory containing the 'Processed_Samples' folder used in steps 1–3 of SnakeCap. Default is the current directory.
#' @param targets.path Path to the file containing the loci that were targetted for capture, and from which probes were designed.
#' @param minOverlap Minimum number of matching bases required between the contig and reference target to retain the match. Default 41.
#' @param maxeval Maximum e-value allowed to retain a match. Default 0.05.
#' @param minbitscore Minimum bitscore allowed to retain a match. Default 50. 
#' @return NULL
#' @export
targetMatchingAssessment03b <- function(workdir=getwd(), targets.path, minOverlap=41, maxeval=0.05, minbitscore=50){
	procdir <- file.path(workdir,"/Processed_Samples/")
	setwd(procdir)
	
	# paths to consensus contig fasta files (consensus among haplocontigs of an individual)
	consensusContigs.paths <- list.files(pattern='.+_consensus-contigs-dipspades.fa',recursive=T,full.names=T)
	# paths to hit tables
	matches.paths <- list.files(pattern='.+_match.txt$',recursive=T, full.names=T)
	
	# Checking that input files exist
	if(length(consensusContigs.paths) == 0){
		stop("Could not find '*_consensus-contigs-dipspades.fa' files generated by dipspades")
	}
	if(length(matches.paths) == 0){
		stop("Could not find files with pattern '*_match.txt' (hit tables) generated by BLAST")
	}
	if(length(consensusContigs.paths)!=length()){
		stop("Number of sequence consensus contig files with filenames '.+_consensus-contigs-dipspades.fa' differs from number of hit tables with filenames '*_match.txt'")
	}

	# For the ith individual, filter/sort the set of matches in the BLAST hit table, and sorted write sequences
	for(i in 1:length(matches.paths)){
		SampleName            <- basename(dirname(matches.paths[i]))
		match.data <- data.table::fread(matches.paths[i], sep = "\t", header = F, stringsAsFactors = FALSE)
		headers    <- c("qName", "tName", "pident", "matches", "misMatches", "gapopen","qStart", "qEnd", "tStart", "tEnd", "evalue", "bitscore")
		data.table::setnames(match.data, headers)
		# Moderate or strong matches
		filt.data <- match.data[match.data$matches > minOverlap & match.data$evalue <= maxeval & match.data$bitscore >= minbitscore,]
		# Remove weak matches
		matches.removed <- match.data[match.data$matches <= minOverlap | match.data$evalue > maxeval | match.data$bitscore < minbitscore,]
		
		# Read in assembled contigs
		contigs <- Biostrings::readDNAStringSet(consensusContigs.paths[i])
		names(contigs) <- gsub(" .+","",names(contigs))
		# Read in target loci
		query.seqs <- Biostrings::readDNAStringSet(targets.path)
		
		# Adds a column that will hold direction information
		filt.data[,qDir:= "+"]
		filt.data$qDir[filt.data$tStart > filt.data$tEnd] <- "-"
		
		# New column that holds the contig name and target name for each match
		ContigTarget <- paste(filt.data$qName,filt.data$tName)
		filt.data[,ContigTarget:=paste(filt.data$qName,filt.data$tName)]
		filt.df      <- filt.data[match(unique(filt.data$ContigTarget),filt.data$ContigTarget),]
		
		# Filtered hit table for the set of contigs that match a single target locus. If the contigs are large they may contain multiple targets though.
		filt.df.SingleMatches   <- filt.df[match(names(which(table(filt.df$qName)==1)),filt.df$qName),]
		# Filtered hit table for the set of contigs that match multiple target loci. Not sure what to do with these yet
		filt.df.MultipleMatches <- filt.df[filt.df$qName %in% names(which(table(filt.df$qName)>1)),]
		
		# Contigs that strongly match only one target
		contigs.single        <- contigs[pmatch(filt.df.SingleMatches$qName,names(contigs))]
		newNames.single       <- paste0(names(contigs.single),"_|_",filt.df.SingleMatches$tName,"_|_",SampleName)
		names(contigs.single) <- newNames.single
		# Write the set of contigs that match a single target locus, and include the sample name, contig name, and target name in the sequence name
		Biostrings::writeXStringSet(contigs.single,file.path(dirname(matches.paths[i]),paste0(SampleName,"_contigs-SingleTargetMatches.fa")))
		# Write the filtered Hit table for the contigs that match a single target
		write.table(filt.df.SingleMatches,file.path(dirname(matches.paths[i]),paste0(SampleName,"_Hits-SingleTargetMatches.tsv")),quote=F,sep="\t",col.names=T,row.names=F)
		
		# Contigs that moderately or strongly match multiple target
		contigs.multi        <- contigs[match(filt.df.MultipleMatches$qName,names(contigs))]
		newNames.multi       <- paste0(names(contigs.multi),"_|_",SampleName)
		names(contigs.multi) <- newNames.multi
		# Write the set of contigs that match multiple target loci, and include the sample name and contig name in the sequence name
		Biostrings::writeXStringSet(contigs.multi,file.path(dirname(matches.paths[i]),paste0(SampleName,"_contigs-MultipleTargetMatches.fa")))
		# Write the filtered Hit table for the contigs that match multiple targets
		write.table(filt.df.MultipleMatches,file.path(dirname(matches.paths[i]),paste0(SampleName,"_Hits-MultipleTargetMatches.tsv")),quote=F,sep="\t",col.names=T,row.names=F)
		
		# Contigs that only weakly match one or more targets
		if(any(!matches.removed$qName %in% filt.data$qName)){
			contigs.weakMatches <- contigs[match(unique(matches.removed$qName[which(!matches.removed$qName %in% filt.data$qName)]),names(contigs))]
			newNames.weak       <- paste0(names(contigs.weakMatches),"_|_",SampleName)
			# Write the set of contigs that had only weak matche(s) to targets, and include the sample name and contig name in the sequence name
			Biostrings::writeXStringSet(contigs.weakMatches,file.path(dirname(matches.paths[i]),paste0(SampleName,"_contigs-WeakTargetMatchesOnly.fa")))
			# write the hit table containing only weak matches
			write.table(matches.removed,file.path(dirname(matches.paths[i]),paste0(SampleName,"_Hits-WeakMatches.tsv")),quote=F,sep="\t",col.names=T,row.names=F)
		}
		
		# Contigs that do not match any targets
		if(any(!names(contigs) %in% match.data$qName)){
			contigs.unmatched  <- contigs[!names(contigs) %in% match.data$qName]
			newNames.unmatched <- paste0(names(contigs.unmatched),"_|_",SampleName)
			# Write the set of contigs that did not match any of the targets
			Biostrings::writeXStringSet(contigs.unmatched,file.path(dirname(matches.paths[i]),paste0(SampleName,"_contigs-unmatched.fa")))
		}
	}
	# res
}

#' Step 4: Align Captured Loci
#'
#' This function performs step 4 of the post-sequencing pipeline used for SnakeCap
#' MAFFT is used for multiple sequence alignment with the settings '--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6', and using a jacknifing approach to find the the set of putatively orthologous contigs among individuals.
#' The input sequences should be the fasta files generated in step 3 that are named '.*contigs-SingleTargetMatches.fa'
#' 
#' @param workdir Path to the directory containing the 'Processed_Samples' folder used in steps 1–3 of SnakeCap. Default is the current directory.
#' @param targets.path Path to the file containing the loci that were targetted for capture, and from which probes were designed.
#' @param istart Number indicating the first locus to process, among the set of unique contigs that do not match other targets. Default 1.
#' @param iend Number indicating the last locus to process, among the set of unique contigs that do not match other targets. Default is NULL, in which case all loci including and after istart will be processed.
#' @return NULL # Later this function will return a data frame with the paths to output files
#' @export 
lociAlignment04 <- function(workdir=getwd(),targets.path, istart=1, iend=NULL){
	# paths to consensus sequence fasta files
	# contigs.paths <- list.files(pattern='.+_consensus-contigs-dipspades.fa',recursive=T,full.names=T)
	#targets.path   <- file.path(workdir,'Weinell_TargetLoci_Snakes_Final_18April2019.txt')
	# paths to hit tables
	# matches.paths <- list.files(pattern='.+_match.txt$',recursive=T, full.names=T)
	# Read in assembled contigs
	# contigs <- Biostrings::readDNAStringSet(contigs.paths)
	setwd(workdir)
	# Read in target loci
	query.seqs <- Biostrings::readDNAStringSet(targets.path)
	# Paths to consensus contigs that strongly match only one target. This file was generated in step 3.
	SingleTargetContigs.paths <- list.files(pattern='.+_contigs-SingleTargetMatches.fa',recursive=T,full.names=T)
	# DNAStringSet holding the consensus contigs that strongly match only one target, for all of the species sampled
	SingleTargetContigs    <- Biostrings::readDNAStringSet(SingleTargetContigs.paths)
	
	##### Define output directories and create them if they do not already exist.
	SingleTargetContigsDir <- file.path(workdir,"/SingleTargetContigs")
	dir.check.create(SingleTargetContigsDir)
	setwd(SingleTargetContigsDir)
	# Directories where each multiple sequence alignment will be written
	AlignmentDir1 <- file.path(SingleTargetContigsDir,"/UntrimmedAlignments_SamplesOnly/")
	AlignmentDir2 <- file.path(SingleTargetContigsDir,"/UntrimmedAlignments_SamplesAndTarget/")
	# Where to write the consensus sequence of each locus alignment
	ConsensusDir  <- file.path(SingleTargetContigsDir,"/AlignmentConsensus_SamplesAndTarget/")
	# Where to write unaligned sequences
	orthologsDir  <- file.path(SingleTargetContigsDir,"/PutativeOrthologs_unaligned/")
	paralogsDir   <- file.path(SingleTargetContigsDir,"/PutativeParalogs_unaligned/")
	unresolvedDir <- file.path(SingleTargetContigsDir,"/UnresolvedHomologs_unaligned/")
	# Directory where sequences will be written if the target was only sequenced in one individual.
	underSampledDir <- file.path(SingleTargetContigsDir,"/undersampledTargets_unaligned/")
	# Create the directories defined above, if they dont already exist.
	dir.check.create(AlignmentDir1)
	dir.check.create(AlignmentDir2)
	dir.check.create(ConsensusDir)
	dir.check.create(unresolvedDir)
	dir.check.create(paralogsDir)
	dir.check.create(orthologsDir)
	dir.check.create(underSampledDir)

	###### For each target, write a separate fasta file containing the set of species' contigs that match it
	# data frame with contig name, target name, and individual name parsed from sequence names
	contigInfo.df <- as.data.frame(do.call(rbind,strsplit(names(SingleTargetContigs),split="_|_",fixed=T)))
	colnames(contigInfo.df) <- c("contig","target","sample")
	# The set of unique target names with at least one matching contig
	uniqueTargets <- unique(contigInfo.df$target)
	# For each target and each individual, the number of sequence contigs
	SampleContigsPerTarget <- table(contigInfo.df[,c("target","sample")])
	IndvsPerTarget         <- SampleContigsPerTarget
	IndvsPerTarget[SampleContigsPerTarget!=0] <- 1
	
	print(sprintf("%s target loci with %s–%s contigs/target and %s–%s individuals/target",length(uniqueTargets), min(rowSums(SampleContigsPerTarget)),max(rowSums(SampleContigsPerTarget)),min(rowSums(IndvsPerTarget)),max(rowSums(IndvsPerTarget))))
	if (is.null(iend)){
		iend <- length(uniqueTargets)
	}
	for(i in istart:iend){
		# DNAStringSet of sample contigs for the ith target
		contigs.i      <- SingleTargetContigs[contigInfo.df$target==uniqueTargets[i]]
		# Number of times that each individual occurs in the sequence set. Would only be once if only orthologs present (assuming consensus haplocontigs are used).
		countSamples   <- table(gsub(".+_\\|_.*_\\|_","",names(contigs.i)))
		# Jump to next target locus if only one individual sequenced
		if(length(countSamples)==1){
			Biostrings::writeXStringSet(contigs.i,file.path(underSampledDir,paste0("/",uniqueTargets[i],"_undersampled.fa")))
			next
		}
		# Jump to next target locus if more than 100 possible alternative alignments
		if(prod(countSamples)>100){
			Biostrings::writeXStringSet(contigs.i,file.path(unresolvedDir,paste0("/",uniqueTargets[i],"_HomologyUnresolved.fa")))
			next
		}
		
		# DNAStringSet of sample contigs and the target for the ith target
		seqs.i         <- c(query.seqs[uniqueTargets[i]],contigs.i)
		# A list of vectors. Each vector holds contig names for putative homologs of the target sequence, one of which is assumed to be an ortholog and the others paralogs to the target sequence.
		alternativeContigs.list <- lapply(names(countSamples),function(x) names(contigs.i)[grep(x,names(contigs.i))])
		# Data frame with each row holding the contig names to include in an alignment. Each row has a different set of contig names, and each column represents an individual. The best-scoring alignment will be saved and assumed to contain orthologous contigs.
		alternativeContigs.df   <- expand.grid(alternativeContigs.list)
		
		# Create empty lists to hold alternative alignments and pairwise genetic distance calculations obtained in the for loop below
		alignments.list <- list(); length(alignments.list) <- nrow(alternativeContigs.df)
		pdist.list      <- list(); length(pdist.list)      <- nrow(alternativeContigs.df)
		
		# Align alternative sets of individuals' contigs for the ith locus, and calculate the pairwise genetic distance for each alternative alignment
		for(j in 1:nrow(alternativeContigs.df)){
			contigs.ij <- seqs.i[as.character(unlist(alternativeContigs.df[j,]))]
			# including the target
			seqs.ij    <- c(query.seqs[uniqueTargets[i]],contigs.ij)
			# alignment for the jth alternative set of contigs for the ith target locus
			aligned.ij <- Biostrings::DNAStringSet(REEs::mafft(seqs.ij, param="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6"))
			# mean pairwise distance of aligned.ij; for now this will be a measure of the 
			meanpdist.ij <- mean(ape::dist.dna(ape::as.DNAbin(aligned.ij),pairwise.deletion=T),na.rm=T)
			alignments.list[[j]] <- aligned.ij
			pdist.list[[j]] <- meanpdist.ij
			print(sprintf("alternative contigs alignment %s of %s determined for target '%s' (%s of %s)",j,nrow(alternativeContigs.df),uniqueTargets[i],i,length(uniqueTargets)))
		}

		# Names of the putatively orthologous contigs (the contigs in the alignment with the lowest pairwise genetic distance)
		bestContigs.names   <- as.character(unlist(alternativeContigs.df[which(unlist(pdist.list)==min(unlist(pdist.list)))[1],]))
		
		# The alignment that includes the best contigs and the reference target
		alignedContigsTarget.best <- alignments.list[[which(unlist(pdist.list)==min(unlist(pdist.list)))[1]]]
		
		# Aligns the best contigs without including the target reference
		contigs.best        <- contigs.i[bestContigs.names]
		alignedContigs.best <- Biostrings::DNAStringSet(REEs::mafft(contigs.best, param="--localpair --maxiterate 1000 --adjustdirection --quiet --op 3 --ep 0.123 --thread 6"))
		
		# Writing the best alignment (with and without the reference target) for the ith target
		Biostrings::writeXStringSet(alignedContigs.best,file.path(AlignmentDir1,paste0("/",uniqueTargets[i],".fa")))
		Biostrings::writeXStringSet(alignedContigsTarget.best,file.path(AlignmentDir2,paste0("/",uniqueTargets[i],".fa")))
		
		# Determining and then writing the consensus sequence of the best alignment that includes contigs and the reference target
		consensus.of.alignedContigsTarget.best <- Biostrings::DNAStringSet(Biostrings::consensusString(Biostrings::DNAStringSet(gsub("-","N",alignedContigsTarget.best)),ambiguityMap=IUPAC_CODE_MAP))
		names(consensus.of.alignedContigsTarget.best) <- paste0(uniqueTargets[i],"_consensus")
		Biostrings::writeXStringSet(consensus.of.alignedContigsTarget.best,file.path(ConsensusDir,paste0("/",uniqueTargets[i],"_consensus.fa")))
		
		# Writing unaligned putative orthologs of the ith target to a fasta file
		Biostrings::writeXStringSet(contigs.best,file.path(orthologsDir,paste0("/",uniqueTargets[i],"_orthologs.fa")))
		
		# Writing unaligned putative paralogs of the ith target to a fasta file
		if(nrow(alternativeContigs.df) > 1){
			paralogs.i   <- contigs.i[setdiff(names(contigs.i),bestContigs.names)]
			paralogInfo  <- as.data.frame(do.call(rbind,strsplit(names(paralogs.i),split="_|_",fixed=T)))
			paralogNames <- sapply(1:nrow(paralogInfo),function(x) paste(data.frame(V1=paralogInfo[x,1],V2=paste0(paralogInfo[x,2],"-putative-paralog"),V3=paralogInfo[x,3]),collapse="_|_"))
			names(paralogs.i) <- paralogNames
			Biostrings::writeXStringSet(paralogs.i,file.path(paralogsDir,paste0("/",uniqueTargets[i],"_paralogs.fa")))
		}
		print(sprintf("ortholog alignment of %s (target %s of %s) complete!",uniqueTargets[i],i,length(uniqueTargets)))
	}
}
## For SnakeCap loci:
# res04 <- lociAlignment04(workdir="/panfs/pfs.local/home/j926w878/scratch/scratch_v3/SequenceCapture/SnakeCap_AllSamples/", targets.path="Weinell_TargetLoci_Snakes_Final_18April2019.txt", istart=1, iend=NULL)
# 







